<h1 id="database-normalization-class-3-advanced-forms-modern-applications">Database
Normalization: Class 3 ‚Äì Advanced Forms &amp; Modern Applications</h1>
<h2 id="bcnf-4nf-5nf-and-real-world-database-design">BCNF, 4NF, 5NF, and
Real-World Database Design</h2>
<h3 id="class-overview-75-minutes">Class Overview (75 minutes)</h3>
<p><strong>Today‚Äôs Agenda:</strong></p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Topic</th>
<th>Format</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-5 min</td>
<td>Quick 3NF Review Quiz</td>
<td>Individual ‚Üí Class discussion</td>
</tr>
<tr>
<td>5-30 min</td>
<td>BCNF: When 3NF Isn‚Äôt Enough</td>
<td>Lecture + Examples</td>
</tr>
<tr>
<td>30-45 min</td>
<td>4NF: Multi-Valued Dependencies</td>
<td>Lecture + Checkpoint</td>
</tr>
<tr>
<td>45-50 min</td>
<td>5NF &amp; Beyond</td>
<td>Brief overview</td>
</tr>
<tr>
<td>50-65 min</td>
<td>Modern Database Patterns</td>
<td>Discussion + Examples</td>
</tr>
<tr>
<td>65-73 min</td>
<td>Real-World Decision Making</td>
<td>Group activity</td>
</tr>
<tr>
<td>73-75 min</td>
<td>Wrap-Up</td>
<td>Summary</td>
</tr>
</tbody>
</table>
<p><strong>Teaching notes:</strong> - Slides/projector for examples
recommended - Students should have paper/pencil for checkpoints -
Emphasize practical decision-making over theoretical perfection</p>
<hr />
<h2 id="learning-objectives">Learning Objectives</h2>
<p>By the end of this lesson, you will be able to:</p>
<ol type="1">
<li><strong>Apply</strong> BCNF principles to tables with complex key
relationships</li>
<li><strong>Recognize</strong> multi-valued dependencies and when 4NF is
needed</li>
<li><strong>Explain</strong> when to stop normalizing (3NF vs BCNF vs
4NF)</li>
<li><strong>Evaluate</strong> trade-offs between normalization and
performance</li>
<li><strong>Design</strong> hybrid approaches using both normalized and
denormalized structures</li>
<li><strong>Justify</strong> normalization decisions based on business
requirements</li>
</ol>
<hr />
<p>üìñ <strong>KEY TERMS FOR TODAY</strong> - <strong>Multi-valued
dependency (MVD)</strong>: Independent sets of values that cause
redundancy (X ‚Üí‚Üí Y) - <strong>Join dependency</strong>: Complex ternary
relationships (three entities) that require 5NF (rare!) -
<strong>Denormalization</strong>: Intentionally adding redundancy for
performance (strategic choice) - <strong>Star schema</strong>: Data
warehouse pattern with intentional denormalization -
<strong>Materialized view</strong>: Pre-computed denormalized query
result stored as table - <strong>CQRS</strong>: Command Query
Responsibility Segregation - different models for reading vs writing</p>
<hr />
<h2 id="quick-review-the-journey-so-far">Quick Review: The Journey So
Far</h2>
<h3 id="normalization-progress">Normalization Progress:</h3>
<p><strong>What we‚Äôve mastered:</strong></p>
<table>
<colgroup>
<col style="width: 39%" />
<col style="width: 33%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr>
<th>Normal Form</th>
<th>Eliminated</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1NF</strong></td>
<td>Non-atomic values, repeating groups</td>
<td>‚Äú555-1234, 555-5678‚Äù ‚Üí separate rows</td>
</tr>
<tr>
<td><strong>2NF</strong></td>
<td>Partial dependencies</td>
<td>ProductName depending on only part of composite key</td>
</tr>
<tr>
<td><strong>3NF</strong></td>
<td>Transitive dependencies</td>
<td>CourseID ‚Üí InstructorID ‚Üí InstructorOffice</td>
</tr>
</tbody>
</table>
<h3 id="for-most-applications">For Most Applications:</h3>
<p><strong>3NF is sufficient</strong> and provides excellent data
integrity while maintaining reasonable query performance.</p>
<p><strong>You‚Äôve already learned the industry standard!</strong> Most
databases you‚Äôll encounter in the real world stop at 3NF.</p>
<hr />
<p>‚úã <strong>CHECKPOINT #0: 3NF Retrieval Practice</strong> (5
minutes)</p>
<p>Before we continue, verify you remember 3NF from Class 2:</p>
<p><strong>Quick Quiz:</strong></p>
<ol type="1">
<li><p><strong>What makes a dependency ‚Äútransitive‚Äù?</strong></p>
<p><strong>Answer:</strong> A ‚Üí B and B ‚Üí C, so A ‚Üí C indirectly (goes
through an intermediate attribute)</p>
<p><strong>Explanation:</strong></p>
<ul>
<li><strong>Direct dependency:</strong> Primary key directly determines
an attribute (EmpID ‚Üí DeptID)</li>
<li><strong>Transitive dependency:</strong> Primary key determines an
attribute <em>through</em> another non-key attribute (EmpID ‚Üí DeptID ‚Üí
DeptName)</li>
<li>The dependency ‚Äúpasses through‚Äù the intermediate attribute
(DeptID)</li>
<li>Think of it as a chain: If A determines B, and B determines C, then
A indirectly determines C</li>
<li><strong>Problem:</strong> Changes to the intermediate value (DeptID)
require updates in multiple places</li>
</ul></li>
<li><p><strong>In this chain, which table eliminates the transitive
dependency?</strong></p>
<pre><code>EmpID ‚Üí DeptID ‚Üí DeptName</code></pre>
<p><strong>Answer:</strong> Create DEPARTMENT table with DeptID ‚Üí
DeptName, keep only DeptID in EMPLOYEE table</p>
<p><strong>Explanation:</strong></p>
<ul>
<li><p><strong>Before (violates 3NF):</strong></p>
<pre><code>EMPLOYEE(EmpID, EmpName, DeptID, DeptName)</code></pre>
<p>Problem: DeptName depends on DeptID, not directly on EmpID (the
primary key)</p></li>
<li><p><strong>After (achieves 3NF):</strong></p>
<pre><code>EMPLOYEE(EmpID, EmpName, DeptID)
DEPARTMENT(DeptID, DeptName)</code></pre>
<p>Now DeptName directly depends on DeptID (its primary key in
DEPARTMENT table)</p></li>
<li><p><strong>Why this works:</strong> Each non-key attribute depends
ONLY on its table‚Äôs primary key</p></li>
<li><p><strong>Benefit:</strong> Update a department name in ONE place,
not in every employee record</p></li>
</ul></li>
<li><p><strong>True or False: Every non-key attribute should depend
directly on the primary key.</strong></p>
<p><strong>Answer:</strong> TRUE - that‚Äôs what 3NF ensures!</p>
<p><strong>Explanation:</strong></p>
<ul>
<li><strong>3NF Rule:</strong> No non-key attribute can depend on
another non-key attribute</li>
<li>Every non-key attribute must have a <strong>direct functional
dependency</strong> on the primary key</li>
<li><strong>No chains allowed:</strong> You shouldn‚Äôt be able to trace:
PK ‚Üí Non-key ‚Üí Another Non-key</li>
<li>If you find such a chain, extract the second part into its own
table</li>
<li><strong>Test:</strong> For each non-key attribute, ask ‚ÄúDoes this
depend on the WHOLE primary key and NOTHING BUT the primary key?‚Äù</li>
</ul>
<p><strong>Example of violation:</strong></p>
<pre><code>STUDENT(StudentID, CourseID, InstructorID, InstructorOffice)</code></pre>
<ul>
<li>InstructorOffice depends on InstructorID (not directly on the
primary key)</li>
<li>This is transitive: {StudentID, CourseID} ‚Üí InstructorID ‚Üí
InstructorOffice</li>
<li><strong>Fix:</strong> Move InstructorOffice to an INSTRUCTOR
table</li>
</ul></li>
</ol>
<p><strong>If you struggled, review Class 2 notes (lines 219-305) before
continuing.</strong></p>
<hr />
<h2 id="boyce-codd-normal-form-bcnf">Boyce-Codd Normal Form (BCNF)</h2>
<h3 id="reminder-when-3nf-isnt-quite-enough">Reminder: When 3NF Isn‚Äôt
Quite Enough</h3>
<p><strong>From Class 2, you learned:</strong> - BCNF is stricter than
3NF - Most databases don‚Äôt need BCNF - BCNF handles special edge
cases</p>
<p><strong>Today we‚Äôll dive deeper</strong> into recognizing BCNF
violations and deciding when to apply it.</p>
<hr />
<p>üìñ <strong>BCNF KEY TERMS</strong></p>
<p><strong>Superkey:</strong> Any set of attributes that uniquely
identifies a row (can have extra attributes) - Example: In
STUDENT(StudentID, Email, Name), both {StudentID} and {StudentID, Name}
are superkeys - Think: Anything that guarantees uniqueness</p>
<p><strong>Candidate Key:</strong> A <strong>minimal</strong> superkey
(can‚Äôt remove any attribute without losing uniqueness) - Example:
{StudentID} is a candidate key, but {StudentID, Name} is NOT (Name is
redundant) - Think: The smallest combination that uniquely identifies
rows - One candidate key becomes the primary key</p>
<p><strong>Determinant:</strong> The left side of a functional
dependency (X in X ‚Üí Y) - Example: In StudentID ‚Üí Name, StudentID is the
determinant - Think: The attribute(s) that ‚Äúcontrol‚Äù or determine other
values</p>
<p><strong>BCNF Rule:</strong> Every determinant must be a superkey</p>
<p><strong>Why BCNF matters:</strong></p>
<pre><code>Table: ENROLLMENT(StudentID, CourseID, Instructor, InstructorOffice)
Primary key: {StudentID, CourseID}

Functional dependency: Instructor ‚Üí InstructorOffice</code></pre>
<ul>
<li>Instructor is a determinant (determines InstructorOffice)</li>
<li>But Instructor is NOT a superkey (doesn‚Äôt uniquely identify
rows)</li>
<li><strong>BCNF violation!</strong> ‚Üí Need to separate INSTRUCTOR
table</li>
</ul>
<hr />
<h3 id="bcnf-requirements">BCNF Requirements:</h3>
<ol type="1">
<li>‚úÖ Table is in 3NF</li>
<li>‚úÖ For <strong>every</strong> functional dependency X ‚Üí Y, X must be
a <strong>superkey</strong></li>
</ol>
<p><strong>Key difference from 3NF:</strong> - 3NF says: ‚ÄúNon-key
attributes can‚Äôt depend on other non-key attributes‚Äù - BCNF says:
‚Äú<strong>Nothing</strong> can determine anything unless it‚Äôs a
superkey‚Äù</p>
<hr />
<h3 id="simple-bcnf-example-building-understanding">Simple BCNF Example
(Building Understanding)</h3>
<p><strong>Before diving into complex cases, let‚Äôs start
simple:</strong></p>
<p><strong>Scenario:</strong> Library tracks which books are on which
shelves. - Each book is on exactly one shelf - Each shelf is in exactly
one room - <strong>Business rule:</strong> Each room has shelves
numbered 1, 2, 3, etc. (numbering restarts in each room)</p>
<p><strong>Table:</strong></p>
<table>
<thead>
<tr>
<th>BookID</th>
<th>ShelfNum</th>
<th>RoomNum</th>
<th>BookTitle</th>
</tr>
</thead>
<tbody>
<tr>
<td>B001</td>
<td>1</td>
<td>101</td>
<td>Database 101</td>
</tr>
<tr>
<td>B002</td>
<td>2</td>
<td>101</td>
<td>SQL Basics</td>
</tr>
<tr>
<td>B003</td>
<td>1</td>
<td>102</td>
<td>Python Guide</td>
</tr>
</tbody>
</table>
<p><strong>Primary Key:</strong> BookID</p>
<p><strong>Functional Dependencies:</strong></p>
<pre><code>BookID ‚Üí ShelfNum, RoomNum, BookTitle  ‚úì (Primary key determines everything)
ShelfNum, RoomNum ‚Üí (nothing)           (Not determinant of other attributes)</code></pre>
<p><strong>Is this BCNF?</strong> YES! - The only determinant is BookID,
which IS a superkey - All dependencies have a superkey on the left
side</p>
<p><strong>Now let‚Äôs modify the scenario to create a BCNF
violation:</strong></p>
<hr />
<h3 id="bcnf-violation-example">BCNF Violation Example</h3>
<p><strong>New scenario:</strong> Same library, but now: - Each shelf
can have multiple books - Primary key becomes: <strong>{BookID}</strong>
(each book still appears once) - But we add: Each shelf is managed by
one librarian - <strong>New constraint:</strong> Librarians only manage
shelves in ONE room</p>
<p><strong>Modified Table:</strong></p>
<table>
<thead>
<tr>
<th>BookID</th>
<th>ShelfNum</th>
<th>RoomNum</th>
<th>LibrarianID</th>
<th>BookTitle</th>
</tr>
</thead>
<tbody>
<tr>
<td>B001</td>
<td>S1</td>
<td>101</td>
<td>L05</td>
<td>Database 101</td>
</tr>
<tr>
<td>B002</td>
<td>S1</td>
<td>101</td>
<td>L05</td>
<td>SQL Basics</td>
</tr>
<tr>
<td>B003</td>
<td>S2</td>
<td>102</td>
<td>L07</td>
<td>Python Guide</td>
</tr>
<tr>
<td>B004</td>
<td>S2</td>
<td>102</td>
<td>L07</td>
<td>Data Mining</td>
</tr>
</tbody>
</table>
<p><strong>Primary Key:</strong> BookID</p>
<p><strong>Functional Dependencies:</strong></p>
<pre><code>BookID ‚Üí ShelfNum, RoomNum, LibrarianID, BookTitle  ‚úì (Primary key)
ShelfNum ‚Üí LibrarianID, RoomNum                     ‚úó PROBLEM!</code></pre>
<p><strong>BCNF Violation:</strong> -
<code>ShelfNum ‚Üí LibrarianID</code> exists - But ShelfNum is <strong>NOT
a superkey</strong> (it doesn‚Äôt uniquely identify rows) - Yet it
determines other attributes</p>
<p><strong>Is this 3NF?</strong> YES! (No transitive dependencies from
the primary key) <strong>Is this BCNF?</strong> NO! (Determinant that
isn‚Äôt a superkey)</p>
<hr />
<h3 id="bcnf-solution">BCNF Solution:</h3>
<p><strong>BOOK Table:</strong></p>
<table>
<thead>
<tr>
<th>BookID</th>
<th>ShelfNum</th>
<th>BookTitle</th>
</tr>
</thead>
<tbody>
<tr>
<td>B001</td>
<td>S1</td>
<td>Database 101</td>
</tr>
<tr>
<td>B002</td>
<td>S1</td>
<td>SQL Basics</td>
</tr>
<tr>
<td>B003</td>
<td>S2</td>
<td>Python Guide</td>
</tr>
<tr>
<td>B004</td>
<td>S2</td>
<td>Data Mining</td>
</tr>
</tbody>
</table>
<p><strong>SHELF Table:</strong></p>
<table>
<thead>
<tr>
<th>ShelfNum</th>
<th>LibrarianID</th>
<th>RoomNum</th>
</tr>
</thead>
<tbody>
<tr>
<td>S1</td>
<td>L05</td>
<td>101</td>
</tr>
<tr>
<td>S2</td>
<td>L07</td>
<td>102</td>
</tr>
</tbody>
</table>
<p><strong>Now:</strong> - <code>BookID ‚Üí ShelfNum, BookTitle</code> ‚úì
BookID is a superkey - <code>ShelfNum ‚Üí LibrarianID, RoomNum</code> ‚úì
ShelfNum is a superkey in SHELF table</p>
<p><strong>Benefits:</strong> - ‚úÖ Can add new shelves without adding
books - ‚úÖ Changing a librarian assignment happens in ONE place - ‚úÖ
Deleting all books from a shelf doesn‚Äôt lose shelf info</p>
<hr />
<h3 id="the-classic-bcnf-example-student-course-instructor">The Classic
BCNF Example: Student-Course-Instructor</h3>
<p><strong>Constraints:</strong> - Students enroll in courses - Each
course section has one instructor - <strong>Key constraint:</strong>
Each instructor teaches only ONE subject (e.g., Dr.¬†Smith only teaches
Programming)</p>
<p><strong>Table:</strong></p>
<table>
<thead>
<tr>
<th>StudentID</th>
<th>CourseID</th>
<th>Instructor</th>
<th>Subject</th>
</tr>
</thead>
<tbody>
<tr>
<td>S01</td>
<td>CS101</td>
<td>Dr.¬†Smith</td>
<td>Programming</td>
</tr>
<tr>
<td>S01</td>
<td>CS101</td>
<td>Dr.¬†Jones</td>
<td>Programming</td>
</tr>
<tr>
<td>S02</td>
<td>MATH201</td>
<td>Dr.¬†Adams</td>
<td>Mathematics</td>
</tr>
</tbody>
</table>
<p>Wait - two rows with S01 and CS101? Yes! This happens when a course
has multiple sections with different instructors.</p>
<p><strong>Primary Key:</strong> {StudentID, CourseID, Instructor}</p>
<p><strong>Functional Dependencies:</strong></p>
<pre><code>{StudentID, CourseID, Instructor} ‚Üí Subject    ‚úì (Primary key)
Instructor ‚Üí Subject                           ‚úó BCNF Violation!</code></pre>
<p><strong>The Problem:</strong> - Instructor determines Subject - But
Instructor is NOT a superkey (doesn‚Äôt uniquely identify rows) - Subject
appears redundantly</p>
<p><strong>BCNF Solution:</strong></p>
<p><strong>ENROLLMENT Table:</strong></p>
<table>
<thead>
<tr>
<th>StudentID</th>
<th>CourseID</th>
<th>Instructor</th>
</tr>
</thead>
<tbody>
<tr>
<td>S01</td>
<td>CS101</td>
<td>Dr.¬†Smith</td>
</tr>
<tr>
<td>S01</td>
<td>CS101</td>
<td>Dr.¬†Jones</td>
</tr>
<tr>
<td>S02</td>
<td>MATH201</td>
<td>Dr.¬†Adams</td>
</tr>
</tbody>
</table>
<p><strong>INSTRUCTOR_SUBJECT Table:</strong></p>
<table>
<thead>
<tr>
<th>Instructor</th>
<th>Subject</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dr.¬†Smith</td>
<td>Programming</td>
</tr>
<tr>
<td>Dr.¬†Jones</td>
<td>Programming</td>
</tr>
<tr>
<td>Dr.¬†Adams</td>
<td>Mathematics</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="when-to-apply-bcnf-decision-guide">When to Apply BCNF: Decision
Guide</h3>
<pre><code>START: Is your table in 3NF?
  ‚Üì NO ‚Üí Fix 3NF first, then return
  ‚Üì YES

Do you have ANY functional dependencies where the determinant is NOT a superkey?
  ‚Üì NO ‚Üí You&#39;re already in BCNF! Done.
  ‚Üì YES

Question: Is this causing actual problems in your application?
Examples:
  - Insertion anomaly (can&#39;t add data without other unrelated data)
  - Update anomaly (changing one fact requires multiple updates)
  - Deletion anomaly (removing data loses other important information)

  ‚Üì NO REAL PROBLEMS ‚Üí Stay at 3NF
     Reason: BCNF adds complexity without benefit

  ‚Üì YES, PROBLEMS EXIST

Question: Will BCNF decomposition lose important information?
  ‚Üì YES ‚Üí Document the trade-off, likely stay at 3NF
  ‚Üì NO ‚Üí Apply BCNF

FOR MOST STUDENTS: Stopping at 3NF is correct!</code></pre>
<hr />
<p>‚úã <strong>CHECKPOINT #1: BCNF Understanding</strong></p>
<p><strong>Scenario:</strong> Course sections with rooms</p>
<table>
<thead>
<tr>
<th>SectionID</th>
<th>CourseCode</th>
<th>Room</th>
<th>Building</th>
</tr>
</thead>
<tbody>
<tr>
<td>SEC01</td>
<td>CS101</td>
<td>210</td>
<td>SciHall</td>
</tr>
<tr>
<td>SEC02</td>
<td>MATH201</td>
<td>105</td>
<td>MathBldg</td>
</tr>
</tbody>
</table>
<ul>
<li>Primary Key: SectionID</li>
<li>Constraint: Each room is in exactly one building</li>
</ul>
<p><strong>Questions:</strong> 1. What functional dependencies exist? 2.
Is this BCNF? Why or why not? 3. If violated, how would you fix it?</p>
<p><strong>Answers:</strong> 1. Dependencies: -
<code>SectionID ‚Üí CourseCode, Room, Building</code> -
<code>Room ‚Üí Building</code> ‚Üê This is the issue!</p>
<ol start="2" type="1">
<li><p>NOT BCNF because:</p>
<ul>
<li><code>Room ‚Üí Building</code> exists</li>
<li>But Room is not a superkey</li>
</ul></li>
<li><p>Fix: Create ROOM table:</p>
<pre><code>SECTION: (SectionID, CourseCode, Room)
ROOM: (Room, Building)</code></pre></li>
</ol>
<p><em>Take 3 minutes - discuss with partner before checking
answer.</em></p>
<hr />
<h2 id="fourth-normal-form-4nf">Fourth Normal Form (4NF)</h2>
<h3 id="the-problem-multi-valued-dependencies">The Problem: Multi-valued
Dependencies</h3>
<p><strong>Even with BCNF,</strong> we can have redundancy when
<strong>independent multi-valued relationships</strong> exist.</p>
<p><strong>Multi-valued Dependency (MVD) Definition:</strong></p>
<p><code>X ‚Üí‚Üí Y</code> means ‚Äúfor each value of X, there is a
<strong>set</strong> of Y values that are <strong>independent</strong>
of other attributes.‚Äù</p>
<p><strong>Key word: INDEPENDENT</strong></p>
<hr />
<h3 id="real-world-example-student-activities">Real-World Example:
Student Activities</h3>
<p><strong>Scenario:</strong> - Students enroll in multiple courses -
Students join multiple clubs - <strong>Courses and clubs are completely
independent</strong> (joining Chess Club doesn‚Äôt relate to taking
CS101)</p>
<p><strong>Student_Info Table (BCNF, but problematic):</strong></p>
<table>
<thead>
<tr>
<th>StudentID</th>
<th>Course</th>
<th>Activity</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>CS101</td>
<td>Chess Club</td>
</tr>
<tr>
<td>101</td>
<td>CS101</td>
<td>Drama Club</td>
</tr>
<tr>
<td>101</td>
<td>CS101</td>
<td>Soccer</td>
</tr>
<tr>
<td>101</td>
<td>MATH201</td>
<td>Chess Club</td>
</tr>
<tr>
<td>101</td>
<td>MATH201</td>
<td>Drama Club</td>
</tr>
<tr>
<td>101</td>
<td>MATH201</td>
<td>Soccer</td>
</tr>
<tr>
<td>101</td>
<td>ENG101</td>
<td>Chess Club</td>
</tr>
<tr>
<td>101</td>
<td>ENG101</td>
<td>Drama Club</td>
</tr>
<tr>
<td>101</td>
<td>ENG101</td>
<td>Soccer</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="the-problems">The Problems:</h3>
<p><strong>Multi-valued Dependencies:</strong> -
<code>StudentID ‚Üí‚Üí Course</code> (independent of Activity) -
<code>StudentID ‚Üí‚Üí Activity</code> (independent of Course)</p>
<p><strong>Issues Created:</strong></p>
<ol type="1">
<li><strong>Storage Explosion:</strong> 3 courses √ó 3 activities =
<strong>9 rows</strong> for one student!</li>
<li><strong>Insertion Anomaly:</strong> Add new course (PHYS101)?
<ul>
<li>Must add 3 rows (one for each activity)</li>
<li>Or add without activities (leaves partial data)</li>
</ul></li>
<li><strong>Update Complexity:</strong> Student drops Drama Club?
<ul>
<li>Must delete 3 rows (one for each course)</li>
<li>Error-prone and inefficient</li>
</ul></li>
<li><strong>Logical Confusion:</strong> The data suggests courses and
activities are related when they‚Äôre not</li>
</ol>
<hr />
<h3 id="nf-requirements">4NF Requirements:</h3>
<ol type="1">
<li>‚úÖ Table is in BCNF</li>
<li>‚úÖ No non-trivial multi-valued dependencies exist</li>
<li>‚úÖ For every multi-valued dependency X ‚Üí‚Üí Y, X is a superkey</li>
</ol>
<p><strong>Simple rule:</strong> If you have
<strong>independent</strong> multi-valued facts, <strong>separate
them</strong>!</p>
<hr />
<h3 id="nf-solution-separate-independent-relationships">4NF Solution:
Separate Independent Relationships</h3>
<p><strong>Student_Course Table:</strong></p>
<table>
<thead>
<tr>
<th>StudentID</th>
<th>Course</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>CS101</td>
</tr>
<tr>
<td>101</td>
<td>MATH201</td>
</tr>
<tr>
<td>101</td>
<td>ENG101</td>
</tr>
</tbody>
</table>
<p><strong>Student_Activity Table:</strong></p>
<table>
<thead>
<tr>
<th>StudentID</th>
<th>Activity</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>Chess Club</td>
</tr>
<tr>
<td>101</td>
<td>Drama Club</td>
</tr>
<tr>
<td>101</td>
<td>Soccer</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="benefits-of-4nf">Benefits of 4NF:</h3>
<p><strong>Before (9 rows):</strong></p>
<pre><code>Student 101: 3 courses √ó 3 activities = 9 rows</code></pre>
<p><strong>After (6 rows):</strong></p>
<pre><code>Student_Course: 3 rows
Student_Activity: 3 rows
Total: 6 rows (33% reduction!)</code></pre>
<p>‚úÖ <strong>Reduced Storage:</strong> 6 rows instead of 9 ‚úÖ
<strong>Independent Management:</strong> Add courses without affecting
activities ‚úÖ <strong>Logical Clarity:</strong> Separate concerns are
separated ‚úÖ <strong>Elimination of Anomalies:</strong> Each
relationship managed independently</p>
<p><strong>Add new course?</strong> 1 row (not 3) <strong>Drop an
activity?</strong> 1 row deleted (not 3) <strong>No spurious
relationships</strong> suggested</p>
<hr />
<h3 id="another-example-employee-skills-and-projects">Another Example:
Employee Skills and Projects</h3>
<p><strong>Before 4NF:</strong></p>
<table>
<thead>
<tr>
<th>EmployeeID</th>
<th>Skill</th>
<th>Project</th>
</tr>
</thead>
<tbody>
<tr>
<td>E001</td>
<td>Java</td>
<td>ProjectA</td>
</tr>
<tr>
<td>E001</td>
<td>Java</td>
<td>ProjectB</td>
</tr>
<tr>
<td>E001</td>
<td>Python</td>
<td>ProjectA</td>
</tr>
<tr>
<td>E001</td>
<td>Python</td>
<td>ProjectB</td>
</tr>
<tr>
<td>E001</td>
<td>SQL</td>
<td>ProjectA</td>
</tr>
<tr>
<td>E001</td>
<td>SQL</td>
<td>ProjectB</td>
</tr>
</tbody>
</table>
<p><strong>Multi-valued dependencies:</strong> - Employee E001 has
skills: {Java, Python, SQL} - Employee E001 works on projects:
{ProjectA, ProjectB} - <strong>These are independent!</strong> Having
Java skill doesn‚Äôt mean assigned to ProjectA</p>
<p><strong>Storage explosion:</strong> 3 skills √ó 2 projects = 6
rows</p>
<hr />
<p><strong>After 4NF:</strong></p>
<p><strong>Employee_Skills Table:</strong></p>
<table>
<thead>
<tr>
<th>EmployeeID</th>
<th>Skill</th>
</tr>
</thead>
<tbody>
<tr>
<td>E001</td>
<td>Java</td>
</tr>
<tr>
<td>E001</td>
<td>Python</td>
</tr>
<tr>
<td>E001</td>
<td>SQL</td>
</tr>
</tbody>
</table>
<p><strong>Employee_Projects Table:</strong></p>
<table>
<thead>
<tr>
<th>EmployeeID</th>
<th>Project</th>
</tr>
</thead>
<tbody>
<tr>
<td>E001</td>
<td>ProjectA</td>
</tr>
<tr>
<td>E001</td>
<td>ProjectB</td>
</tr>
</tbody>
</table>
<p><strong>Storage:</strong> 3 + 2 = 5 rows (16% reduction, more
importantly: logical clarity!)</p>
<hr />
<h3 id="visual-understanding-4nf">Visual Understanding: 4NF</h3>
<pre><code>BEFORE (Mixed Independent Facts):
[Student 101] ‚Üê‚Üí [CS101, MATH201, ENG101] ‚ö° [Chess, Drama, Soccer]
                    All combinations created = 3 √ó 3 = 9 rows

AFTER (Separated Independent Facts):
[Student 101] ‚Üê‚Üí [CS101, MATH201, ENG101]     (3 rows)
[Student 101] ‚Üê‚Üí [Chess, Drama, Soccer]       (3 rows)
                    No cross-product = 3 + 3 = 6 rows</code></pre>
<p><strong>The ‚ö° symbol shows where inappropriate multiplication
happens!</strong></p>
<hr />
<p>‚úã <strong>CHECKPOINT #2: Recognizing Multi-Valued
Dependencies</strong></p>
<p><strong>Scenario:</strong> Authors and Books</p>
<table>
<thead>
<tr>
<th>AuthorID</th>
<th>BookISBN</th>
<th>PhoneNumber</th>
</tr>
</thead>
<tbody>
<tr>
<td>A01</td>
<td>B001</td>
<td>555-1111</td>
</tr>
<tr>
<td>A01</td>
<td>B001</td>
<td>555-2222</td>
</tr>
<tr>
<td>A01</td>
<td>B002</td>
<td>555-1111</td>
</tr>
<tr>
<td>A01</td>
<td>B002</td>
<td>555-2222</td>
</tr>
</tbody>
</table>
<ul>
<li>Author A01 wrote books B001 and B002</li>
<li>Author A01 has phone numbers 555-1111 and 555-2222</li>
<li>Books and phone numbers are independent</li>
</ul>
<p><strong>Questions:</strong> 1. How many rows would exist if A01 wrote
3 books and had 3 phone numbers? 2. Is this 4NF? 3. How would you
decompose it?</p>
<p><strong>Answers:</strong> 1. 3 books √ó 3 phones = <strong>9
rows</strong> (explosive!) 2. NO - has multi-valued dependencies: -
<code>AuthorID ‚Üí‚Üí BookISBN</code> (independent of PhoneNumber) -
<code>AuthorID ‚Üí‚Üí PhoneNumber</code> (independent of BookISBN) 3.
Decompose into:
<code>AUTHOR_BOOKS: (AuthorID, BookISBN)     [3 rows]    AUTHOR_PHONES: (AuthorID, PhoneNumber) [3 rows]    Total: 6 rows instead of 9!</code></p>
<p><em>Discuss: Why is this better? What anomalies are
prevented?</em></p>
<hr />
<h2 id="fifth-normal-form-5nf---brief-introduction">Fifth Normal Form
(5NF) - Brief Introduction</h2>
<h3 id="when-4nf-isnt-enough-very-rare">When 4NF Isn‚Äôt Enough (Very
Rare!)</h3>
<p><strong>Reality check:</strong> 5NF violations are <strong>extremely
rare</strong> in typical business applications. You‚Äôll likely never
encounter this in practice.</p>
<p><strong>5NF addresses:</strong> Join dependencies - complex
<strong>ternary relationships</strong> (involving three entities) that
can‚Äôt be properly decomposed even in 4NF.</p>
<p><strong>Key concept:</strong> Sometimes you really do need a table
with three entities! Attempting to decompose it would create spurious
(false) data when you join the tables back together.</p>
<hr />
<h3 id="practical-note-on-5nf">Practical Note on 5NF:</h3>
<p><strong>When you‚Äôll see this:</strong> Almost never in typical
applications!</p>
<p><strong>Most ‚Äúternary‚Äù relationships</strong> can actually be modeled
as: - Multiple binary relationships, OR - One primary relationship with
additional attributes</p>
<p><strong>Example of an apparent ternary relationship (NOT truly
5NF):</strong></p>
<pre><code>Student-Course-Grade</code></pre>
<p>This is actually: <strong>Student enrolls in Course</strong> (binary
relationship), with Grade as an attribute of the enrollment itself.</p>
<p><strong>A genuine ternary relationship (5NF)</strong> requires that
all three entities are equally important and independent, and none can
be removed or made subordinate.</p>
<p><strong>For the curious:</strong> See Appendix A for a detailed 5NF
example with the Supplier-Part-Project scenario.</p>
<p><strong>For this course:</strong> Understanding 1NF-3NF thoroughly is
far more valuable than memorizing 5NF edge cases!</p>
<hr />
<h2 id="in-class-practice-advanced-normal-forms-10-minutes">üß© In-Class
Practice: Advanced Normal Forms (10 minutes)</h2>
<p><strong>üë®‚Äçüè´ Instructor Note:</strong> This is a guided practice. Walk
through the example with the class, pausing for student input. Don‚Äôt
distribute as independent work unless time permits.</p>
<h3 id="conference-speakers-example">Conference Speakers Example</h3>
<p><strong>Instructions for students:</strong> ‚ÄúLet‚Äôs work through this
together. Take 2 minutes to look at this table and think about what
dependencies exist.‚Äù</p>
<p><strong>Scenario:</strong></p>
<table>
<thead>
<tr>
<th>ConferenceID</th>
<th>SpeakerID</th>
<th>Topic</th>
<th>Expertise</th>
</tr>
</thead>
<tbody>
<tr>
<td>C01</td>
<td>SP1</td>
<td>AI Ethics</td>
<td>Ethics</td>
</tr>
<tr>
<td>C01</td>
<td>SP1</td>
<td>Privacy</td>
<td>Ethics</td>
</tr>
<tr>
<td>C01</td>
<td>SP2</td>
<td>ML Algorithms</td>
<td>Machine Learning</td>
</tr>
<tr>
<td>C02</td>
<td>SP1</td>
<td>AI Ethics</td>
<td>Ethics</td>
</tr>
<tr>
<td>C02</td>
<td>SP1</td>
<td>Privacy</td>
<td>Ethics</td>
</tr>
</tbody>
</table>
<p><strong>Constraints:</strong> - Conferences have multiple speakers -
Speakers present on multiple topics at a conference - Each speaker has
ONE area of expertise - Topics and conferences are independent</p>
<p><strong>Tasks:</strong> 1. What‚Äôs the primary key? 2. Is this BCNF?
(Check for non-superkey determinants) 3. Is this 4NF? (Check for
independent multi-valued dependencies) 4. Decompose if necessary</p>
<p><strong>Guided Help:</strong> - <strong>BCNF:</strong> Does SpeakerID
determine anything? Is SpeakerID a superkey? - <strong>4NF:</strong> Are
SpeakerID and Topic independent of ConferenceID?</p>
<hr />
<h3 id="solution-walkthrough">Solution Walkthrough</h3>
<p><strong>üë®‚Äçüè´ Instructor: Ask students first, then reveal:</strong></p>
<p><strong>Analysis:</strong></p>
<p><strong>Primary Key:</strong> {ConferenceID, SpeakerID, Topic}</p>
<p><strong>BCNF Check:</strong> - <code>SpeakerID ‚Üí Expertise</code>
exists - SpeakerID is NOT a superkey - <strong>BCNF
VIOLATION!</strong></p>
<p><strong>BCNF Decomposition:</strong></p>
<p><strong>SPEAKER Table:</strong></p>
<table>
<thead>
<tr>
<th>SpeakerID</th>
<th>Expertise</th>
</tr>
</thead>
<tbody>
<tr>
<td>SP1</td>
<td>Ethics</td>
</tr>
<tr>
<td>SP2</td>
<td>Machine Learning</td>
</tr>
</tbody>
</table>
<p><strong>CONFERENCE_SPEAKER_TOPIC Table:</strong></p>
<table>
<thead>
<tr>
<th>ConferenceID</th>
<th>SpeakerID</th>
<th>Topic</th>
</tr>
</thead>
<tbody>
<tr>
<td>C01</td>
<td>SP1</td>
<td>AI Ethics</td>
</tr>
<tr>
<td>C01</td>
<td>SP1</td>
<td>Privacy</td>
</tr>
<tr>
<td>C01</td>
<td>SP2</td>
<td>ML Algorithms</td>
</tr>
<tr>
<td>C02</td>
<td>SP1</td>
<td>AI Ethics</td>
</tr>
<tr>
<td>C02</td>
<td>SP1</td>
<td>Privacy</td>
</tr>
</tbody>
</table>
<p><strong>Now check 4NF:</strong></p>
<p><strong>New Primary Key:</strong> {ConferenceID, SpeakerID,
Topic}</p>
<p><strong>4NF Check:</strong> - For a given {ConferenceID, SpeakerID},
are there multiple Topics? YES - Are topics independent of which
conference? NO - speakers may present different topics at different
conferences - <strong>No 4NF violation</strong> (topics depend on the
conference-speaker combination)</p>
<p><strong>Final Answer:</strong> BCNF decomposition is sufficient!</p>
<hr />
<h2 id="modern-database-considerations">Modern Database
Considerations</h2>
<h3 id="beyond-traditional-normalization-15-minutes">Beyond Traditional
Normalization (15 minutes)</h3>
<p><strong>Reality:</strong> While normalization principles remain
important, modern database applications sometimes require different
approaches.</p>
<p><strong>Key insight:</strong> Normalization is a
<strong>tool</strong>, not a religion. Use it when it serves your
goals!</p>
<p>We‚Äôll explore three common modern patterns where normalization
trade-offs appear:</p>
<hr />
<h3 id="strategic-denormalization-for-performance">1. Strategic
Denormalization for Performance</h3>
<h4 id="when-to-consider-denormalization">When to Consider
Denormalization:</h4>
<p><strong>Scenarios where denormalization helps:</strong></p>
<ol type="1">
<li><strong>Read-heavy applications</strong> (90%+ queries, rare
updates)
<ul>
<li>E-commerce product catalogs</li>
<li>News websites</li>
<li>Reporting dashboards</li>
</ul></li>
<li><strong>High-volume systems</strong>
<ul>
<li>Social media feeds (millions of reads/second)</li>
<li>Real-time applications</li>
</ul></li>
</ol>
<hr />
<h4 id="example-e-commerce-product-display">Example: E-commerce Product
Display</h4>
<p><strong>Scenario:</strong> Displaying product information is the most
common operation (10,000+ queries/second). Product updates are rare (few
times per day).</p>
<p><strong>Fully Normalized (3NF):</strong></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>PRODUCT(ProductID, ProductName, Price, CategoryID, BrandID)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">CATEGORY</span>(CategoryID, CategoryName)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>BRAND(BrandID, BrandName)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Query requires 2 JOINs:</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> p.ProductName, p.Price, c.CategoryName, b.BrandName</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> Product p</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> <span class="kw">Category</span> c <span class="kw">ON</span> p.CategoryID <span class="op">=</span> c.CategoryID</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> Brand b <span class="kw">ON</span> p.BrandID <span class="op">=</span> b.BrandID</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> p.ProductID <span class="op">=</span> <span class="dv">12345</span>;</span></code></pre></div>
<p><strong>Strategically Denormalized:</strong></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>PRODUCT_DISPLAY(ProductID, ProductName, Price, CategoryName, BrandName, CategoryID, BrandID)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- Query requires 0 JOINs:</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> ProductName, Price, CategoryName, BrandName</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> Product_Display</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> ProductID <span class="op">=</span> <span class="dv">12345</span>;</span></code></pre></div>
<p><strong>Trade-off Analysis:</strong></p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Normalized</th>
<th>Denormalized</th>
</tr>
</thead>
<tbody>
<tr>
<td>Query Speed</td>
<td>Slower (2 JOINs)</td>
<td><strong>Fast</strong> (no JOINs)</td>
</tr>
<tr>
<td>Storage</td>
<td>Less</td>
<td><strong>More</strong> (CategoryName repeated)</td>
</tr>
<tr>
<td>Update Complexity</td>
<td>Simple</td>
<td><strong>Complex</strong> (maintain consistency)</td>
</tr>
<tr>
<td>Data Integrity</td>
<td>Guaranteed by FK</td>
<td><strong>Must be maintained</strong> by app</td>
</tr>
</tbody>
</table>
<p><strong>Decision:</strong> Denormalize because: - ‚úÖ 10,000 reads/sec
√ó faster query = <strong>huge performance gain</strong> - ‚úÖ 10
updates/day √ó slightly complex = minimal cost - ‚úÖ Can use triggers to
maintain consistency</p>
<hr />
<h3 id="nosql-document-databases-mongodb">2. NoSQL Document Databases
(MongoDB)</h3>
<p><strong>Traditional SQL databases</strong> enforce normalization
through structure. <strong>NoSQL databases</strong> offer different
trade-offs.</p>
<p><strong>Approach:</strong> Embed related data in documents rather
than separate tables</p>
<p><strong>When to use:</strong> - Data naturally clusters together -
Read entire object frequently - Relationships are one-to-few (not
one-to-millions)</p>
<p><strong>Example - Student Document:</strong></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;_id&quot;</span><span class="fu">:</span> <span class="st">&quot;student_101&quot;</span><span class="fu">,</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;John Smith&quot;</span><span class="fu">,</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;email&quot;</span><span class="fu">:</span> <span class="st">&quot;john@email.com&quot;</span><span class="fu">,</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;enrollments&quot;</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;courseId&quot;</span><span class="fu">:</span> <span class="st">&quot;CS101&quot;</span><span class="fu">,</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;courseName&quot;</span><span class="fu">:</span> <span class="st">&quot;Intro Programming&quot;</span><span class="fu">,</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;instructor&quot;</span><span class="fu">:</span> <span class="st">&quot;Dr. Johnson&quot;</span><span class="fu">,</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;grade&quot;</span><span class="fu">:</span> <span class="st">&quot;A&quot;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span><span class="ot">,</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;courseId&quot;</span><span class="fu">:</span> <span class="st">&quot;MATH201&quot;</span><span class="fu">,</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;courseName&quot;</span><span class="fu">:</span> <span class="st">&quot;Calculus I&quot;</span><span class="fu">,</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;instructor&quot;</span><span class="fu">:</span> <span class="st">&quot;Dr. Williams&quot;</span><span class="fu">,</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;grade&quot;</span><span class="fu">:</span> <span class="st">&quot;B&quot;</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>  <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;activities&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;Chess Club&quot;</span><span class="ot">,</span> <span class="st">&quot;Drama Club&quot;</span><span class="ot">,</span> <span class="st">&quot;Soccer&quot;</span><span class="ot">]</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p><strong>Trade-offs:</strong></p>
<p><strong>Pros:</strong> - ‚úÖ One query gets ALL student info (no
JOINs) - ‚úÖ Intuitive structure matches mental model - ‚úÖ Fast reads for
complete objects</p>
<p><strong>Cons:</strong> - ‚ùå Instructor name duplicated across all
students in that course - ‚ùå Updating course name requires updating many
documents - ‚ùå Can‚Äôt easily query ‚Äúall students in CS101‚Äù without
scanning all students</p>
<p><strong>Best for:</strong> User profiles, product catalogs, content
management</p>
<p><strong>Important:</strong> Normalization principles still apply
within documents - avoid redundant nested data!</p>
<hr />
<h3 id="data-warehousing-star-schema">3. Data Warehousing: Star
Schema</h3>
<p><strong>Pattern:</strong> Intentionally denormalized for analytics
and reporting</p>
<p><strong>Structure:</strong> - <strong>Fact table</strong> (center):
Measures/metrics (sales, clicks, transactions) with foreign keys to
dimensions - <strong>Dimension tables</strong> (edges): Descriptive data
(products, customers, dates, locations) - Named ‚Äústar‚Äù because the fact
table is in the center with dimension tables radiating outward</p>
<p><strong>Example - Sales Star Schema:</strong></p>
<p><strong>FACT_SALES (Center - The ‚ÄúHub‚Äù):</strong></p>
<table>
<thead>
<tr>
<th>SaleID</th>
<th>ProductID</th>
<th>StoreID</th>
<th>Quantity</th>
<th>Revenue</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>P50</td>
<td>ST5</td>
<td>2</td>
<td>1000.00</td>
</tr>
<tr>
<td>1002</td>
<td>P50</td>
<td>ST3</td>
<td>1</td>
<td>500.00</td>
</tr>
<tr>
<td>1003</td>
<td>P75</td>
<td>ST5</td>
<td>3</td>
<td>2100.00</td>
</tr>
</tbody>
</table>
<p><strong>Components:</strong> - <strong>Measures (facts):</strong>
Quantity, Revenue (what we‚Äôre analyzing) - <strong>Foreign
keys:</strong> ProductID, StoreID (links to dimension tables) -
<strong>Primary key:</strong> SaleID (uniquely identifies each
transaction)</p>
<hr />
<p><strong>DIM_PRODUCT (Denormalized Dimension):</strong></p>
<table>
<thead>
<tr>
<th>ProductID</th>
<th>ProductName</th>
<th>Category</th>
<th>Brand</th>
<th>Price</th>
</tr>
</thead>
<tbody>
<tr>
<td>P50</td>
<td>Laptop</td>
<td>Electronics</td>
<td>Dell</td>
<td>500</td>
</tr>
<tr>
<td>P75</td>
<td>Monitor</td>
<td>Electronics</td>
<td>Dell</td>
<td>700</td>
</tr>
<tr>
<td>P82</td>
<td>Desk</td>
<td>Furniture</td>
<td>IKEA</td>
<td>300</td>
</tr>
</tbody>
</table>
<p><strong>Key point:</strong> In normalized 3NF, Category and Brand
would be separate tables. Here, we <strong>intentionally
denormalize</strong> by including them directly for faster queries.</p>
<hr />
<p><strong>DIM_STORE:</strong></p>
<table>
<thead>
<tr>
<th>StoreID</th>
<th>StoreName</th>
<th>City</th>
<th>State</th>
<th>Region</th>
</tr>
</thead>
<tbody>
<tr>
<td>ST3</td>
<td>Portland Downtown</td>
<td>Portland</td>
<td>OR</td>
<td>Northwest</td>
</tr>
<tr>
<td>ST5</td>
<td>Seattle Central</td>
<td>Seattle</td>
<td>WA</td>
<td>Northwest</td>
</tr>
<tr>
<td>ST7</td>
<td>San Francisco Bay</td>
<td>San Fran</td>
<td>CA</td>
<td>West</td>
</tr>
</tbody>
</table>
<p><strong>Key point:</strong> Store location data kept together. In
3NF, you might separate STORE and LOCATION tables.</p>
<hr />
<p><strong>Visualizing the Star Schema:</strong></p>
<pre><code>DIM_PRODUCT -- FACT_SALES -- DIM_STORE</code></pre>
<p>The fact table in the center connects to dimension tables via foreign
keys.</p>
<hr />
<p><strong>Example Query - Sales by Store and Category:</strong></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    s.StoreName,</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    p.<span class="kw">Category</span>,</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">SUM</span>(f.Revenue) <span class="kw">AS</span> TotalRevenue</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> FACT_SALES f</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> DIM_STORE s <span class="kw">ON</span> f.StoreID <span class="op">=</span> s.StoreID</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> DIM_PRODUCT p <span class="kw">ON</span> f.ProductID <span class="op">=</span> p.ProductID</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> s.Region <span class="op">=</span> <span class="st">&#39;Northwest&#39;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> s.StoreName, p.<span class="kw">Category</span>;</span></code></pre></div>
<p><strong>Performance benefits:</strong> - Only 2 JOINs needed (vs.¬†5-6
in fully normalized schema) - Pre-computed attributes (Region, Category)
immediately available - Much faster for analytics queries</p>
<hr />
<p><strong>Why Denormalize in Star Schema?</strong></p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 30%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr>
<th>Aspect</th>
<th>Normalized 3NF</th>
<th>Denormalized Star Schema</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>JOINs required</strong></td>
<td>6-8 JOINs for typical query</td>
<td>2-4 JOINs for same query</td>
</tr>
<tr>
<td><strong>Query complexity</strong></td>
<td>Complex nested JOINs</td>
<td>Simple, intuitive queries</td>
</tr>
<tr>
<td><strong>Query speed</strong></td>
<td>Slower (many JOINs)</td>
<td><strong>Much faster</strong></td>
</tr>
<tr>
<td><strong>Storage</strong></td>
<td>Less (no redundancy)</td>
<td><strong>More</strong> (redundant Category, Brand, etc.)</td>
</tr>
<tr>
<td><strong>Updates</strong></td>
<td>Easy (one place)</td>
<td><strong>Rare</strong> (warehouse is read-only)</td>
</tr>
<tr>
<td><strong>Usability</strong></td>
<td>Requires SQL expertise</td>
<td><strong>Business users can query</strong></td>
</tr>
</tbody>
</table>
<p><strong>Key insight:</strong> Data warehouses are
<strong>read-only</strong> (or updated in batch overnight), so update
anomalies aren‚Äôt a concern. Query performance is paramount!</p>
<hr />
<p><strong>When to Use Star Schema:</strong></p>
<p>‚úÖ <strong>Analytics and reporting systems</strong> - Business
intelligence dashboards - Executive reports - Historical analysis</p>
<p>‚úÖ <strong>Read-heavy workloads</strong> (99%+ queries, rare updates)
- Data warehouse - Data marts - OLAP cubes</p>
<p>‚úÖ <strong>Non-technical users need to query data</strong> - Simpler
structure easier to understand - Fewer JOINs = easier SQL</p>
<p>‚ùå <strong>When NOT to use:</strong> - Transactional systems (use 3NF
instead) - Frequent updates (denormalization causes update complexity) -
Real-time operational data</p>
<hr />
<h2 id="practical-guidelines-for-modern-applications">Practical
Guidelines for Modern Applications</h2>
<h3 id="decision-framework">Decision Framework:</h3>
<pre><code>STEP 1: Start with normalization (3NF)
‚îú‚îÄ Ensures data integrity
‚îú‚îÄ Prevents anomalies
‚îî‚îÄ Industry best practice

STEP 2: Identify pain points
‚îú‚îÄ Slow queries?
‚îú‚îÄ Complex JOINs?
‚îî‚îÄ Performance bottlenecks?

STEP 3: Consider context
‚îú‚îÄ Read-heavy? ‚Üí Denormalization helps
‚îú‚îÄ Write-heavy? ‚Üí Keep normalized
‚îú‚îÄ Mixed? ‚Üí Hybrid approach
‚îî‚îÄ Analytics? ‚Üí Star schema

STEP 4: Apply strategic denormalization
‚îú‚îÄ Measure before optimizing
‚îú‚îÄ Denormalize specific queries
‚îú‚îÄ Maintain integrity with triggers/code
‚îî‚îÄ Document trade-offs</code></pre>
<hr />
<h3 id="use-higher-normalization-3nf-when">Use Higher Normalization
(3NF+) When:</h3>
<p>‚úÖ <strong>Data integrity is critical</strong> - Financial systems
(banking, accounting) - Medical records (HIPAA compliance) - Legal
systems (contracts, case management)</p>
<p>‚úÖ <strong>Write operations are frequent</strong> - Transactional
systems - User-generated content - Collaborative editing</p>
<p>‚úÖ <strong>Storage efficiency matters</strong> - Large datasets -
Historical archives</p>
<p>‚úÖ <strong>Data consistency &gt; query speed</strong> - Inventory
management - Reservation systems</p>
<hr />
<h3 id="consider-denormalization-when">Consider Denormalization
When:</h3>
<p>‚úÖ <strong>Read operations dominate</strong> (90%+ reads) - Product
catalogs - News/blog content - Documentation sites</p>
<p>‚úÖ <strong>Query performance is critical</strong> - Real-time
dashboards - High-traffic websites - Mobile applications</p>
<p>‚úÖ <strong>Data is relatively static</strong> - Reference data -
Historical snapshots</p>
<p>‚úÖ <strong>You can manage update complexity</strong> - Have robust
application logic - Can use triggers/materialized views - Monitoring and
testing in place</p>
<hr />
<h3 id="hybrid-approach-normalized-master-denormalized-views">Hybrid
Approach: Normalized Master + Denormalized Views</h3>
<p><strong>Pattern:</strong> Keep source data normalized, create
denormalized views for queries</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Master tables (3NF) - source of truth</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> Student (StudentID, Name, Email);</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> Course (CourseID, Name, Credits);</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> Enrollment (StudentID, CourseID, Grade);</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Denormalized materialized view for reporting</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">MATERIALIZED</span> <span class="kw">VIEW</span> Student_Transcript <span class="kw">AS</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    s.StudentID,</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    s.Name <span class="kw">AS</span> StudentName,</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    s.Email,</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    c.Name <span class="kw">AS</span> CourseName,</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    c.Credits,</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    e.Grade</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> Student s</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> Enrollment e <span class="kw">ON</span> s.StudentID <span class="op">=</span> e.StudentID</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> Course c <span class="kw">ON</span> e.CourseID <span class="op">=</span> c.CourseID;</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- Refresh view when source data changes</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="kw">REFRESH</span> <span class="kw">MATERIALIZED</span> <span class="kw">VIEW</span> Student_Transcript;</span></code></pre></div>
<p><strong>When to use:</strong> - PostgreSQL, Oracle, SQL Server (have
materialized views) - Read queries are expensive but finite in number -
Can tolerate slightly stale data (refresh every N minutes)</p>
<p><strong>This is the best of both worlds!</strong></p>
<hr />
<h2 id="transfer-practice-real-world-decision-making-8-minutes">üéØ
Transfer Practice: Real-World Decision Making (8 minutes)</h2>
<p><strong>üë®‚Äçüè´ Instructor Note:</strong> Choose ONE scenario based on
class interest. If time is tight, do this as a whole-class discussion
instead of group work.</p>
<h3 id="activity-format">Activity Format:</h3>
<p><strong>Option A - Group Work (if time permits):</strong> 1. Form
groups of 3-4 students (1 min) 2. Groups discuss chosen scenario (4 min)
3. One group shares decision (2 min) 4. Class discussion (1 min)</p>
<p><strong>Option B - Whole Class (if time is short):</strong> 1.
Present scenario (1 min) 2. Think-pair-share (2 min) 3. Class discussion
with instructor guidance (5 min)</p>
<p><strong>Goal:</strong> Apply concepts to make practical, justifiable
decisions!</p>
<hr />
<h3 id="scenario-1-healthcare-records-system">Scenario 1: Healthcare
Records System</h3>
<p><strong>Context:</strong> - Hospital patient records system - Tracks
patient visits, diagnoses, medications - <strong>Critical
requirements:</strong> - HIPAA compliance (data integrity is REQUIRED) -
Audit trail for all changes - Medication allergies must be accurate
(life or death!) - <strong>Usage patterns:</strong> - Moderate reads and
writes (roughly balanced) - Complex queries joining patients, visits,
medications</p>
<p><strong>Design Question:</strong></p>
<p>Should you pursue BCNF/4NF for this system, or stop at 3NF?</p>
<p><strong>Considerations:</strong> - Patient allergies are critical
(wrong data = medical emergency) - Audit requirements mean you need to
track every change - Queries are complex but performance is secondary to
accuracy - System has moderate volume (not millions of
transactions/second)</p>
<p><strong>Discussion Questions:</strong> 1. What normalization level
would you target? Why? 2. Would you ever denormalize in a healthcare
system? 3. How does the ‚Äúlife or death‚Äù factor influence your decision?
4. What if query performance becomes a problem - what would you do?</p>
<hr />
<h3 id="scenario-2-e-learning-analytics-dashboard">Scenario 2:
E-Learning Analytics Dashboard</h3>
<p><strong>Context:</strong> - Dashboard showing student progress across
courses - <strong>Data:</strong> - Student enrollments, quiz scores,
video watch times - Course content, instructor info, assignment
deadlines - <strong>Usage patterns:</strong> - Dashboards loaded
frequently (read-heavy: 95% reads) - Student data updated sporadically
(grades added weekly) - Reports need complex aggregations (average
scores, completion rates) - <strong>Requirements:</strong> - Fast
dashboard load times (&lt;500ms) - Reports with historical data (past 3
years)</p>
<p><strong>Design Question:</strong></p>
<p>How would you balance normalization with reporting performance?</p>
<p><strong>Option A: 3NF only</strong></p>
<pre><code>STUDENTS, COURSES, ENROLLMENTS, ASSIGNMENTS, QUIZ_SCORES
Complex JOINs for every dashboard load</code></pre>
<p><strong>Option B: Hybrid (3NF + materialized views)</strong></p>
<pre><code>Normalized tables for data integrity
+ STUDENT_DASHBOARD_VIEW (denormalized, refreshed hourly)</code></pre>
<p><strong>Option C: Star Schema (data warehouse)</strong></p>
<pre><code>FACT_STUDENT_ACTIVITY (all metrics)
DIM_STUDENT, DIM_COURSE, DIM_TIME (denormalized dimensions)</code></pre>
<p><strong>Discussion Questions:</strong> 1. Which option would you
choose? Why? 2. How does the 95% read ratio affect your decision? 3. Is
‚Äúrefreshed hourly‚Äù acceptable for this use case? 4. Could you use 3NF
for writes and star schema for reads?</p>
<hr />
<h3 id="debrief-discussion">Debrief Discussion</h3>
<p><strong>üë®‚Äçüè´ Instructor: Wrap up with these key points (2
minutes):</strong></p>
<ol type="1">
<li><strong>Scenario 1 (Healthcare):</strong>
<ul>
<li>Data integrity trumps performance</li>
<li>3NF or higher is appropriate</li>
<li>Denormalization only for non-critical data (like reports)</li>
<li>Materialized views can help without compromising source data</li>
</ul></li>
<li><strong>Scenario 2 (Analytics):</strong>
<ul>
<li>Perfect use case for hybrid approach</li>
<li>Normalized transactional data (source of truth)</li>
<li>Denormalized reporting views (performance)</li>
<li>Star schema ideal for analytics workload</li>
</ul></li>
</ol>
<p><strong>The Pattern:</strong></p>
<pre><code>START WITH: What&#39;s most important - integrity or speed?
CONSIDER: Read vs write ratio
DECIDE: Normalize, denormalize, or hybrid
JUSTIFY: Document your trade-offs!</code></pre>
<p><strong>There‚Äôs no single ‚Äúright‚Äù answer</strong> - only
well-reasoned decisions based on requirements!</p>
<hr />
<h2 id="practice-exercise-complete-database-design">Practice Exercise:
Complete Database Design</h2>
<h3 id="objective">Objective</h3>
<p>Practice designing a complete database system applying normalization
concepts learned (1NF-3NF), with justification for design choices.</p>
<p><strong>Note:</strong> This is an optional practice exercise to
reinforce the concepts covered in the three normalization lectures. Use
it to test your understanding!</p>
<hr />
<h3 id="scenario-online-course-platform">Scenario: Online Course
Platform</h3>
<p><strong>Design a database for an online learning platform that
tracks:</strong></p>
<ol type="1">
<li><strong>Students:</strong> Personal info, email, enrollment
date</li>
<li><strong>Courses:</strong> Course info, instructor, price,
category</li>
<li><strong>Enrollments:</strong> Which students are enrolled in which
courses, progress, completion status</li>
</ol>
<p><strong>Key Relationships:</strong> - Students enroll in multiple
courses (M:N relationship) - Courses have one instructor but can have
multiple students - Track enrollment date, progress percentage, and
completion status</p>
<hr />
<h3 id="practice-steps">Practice Steps</h3>
<h4 id="part-1-analysis-and-planning">Part 1: Analysis and Planning</h4>
<p><strong>Entity-Relationship Analysis:</strong> 1. Identify entities
(Student, Course, Enrollment) and their attributes 2. Determine
relationships and cardinalities 3. Document business rules 4. Create ER
diagram (use dbdiagram.io, draw.io, or hand-drawn)</p>
<p><strong>Dependency Analysis:</strong> 1. List all functional
dependencies for each entity 2. Identify which attributes depend on
which keys 3. Look for transitive dependencies</p>
<p><strong>Deliverable Template:</strong></p>
<pre><code>ENTITIES:
- Student: List attributes and identify primary key
- Course: List attributes and identify primary key
- Enrollment: List attributes and identify primary/foreign keys

FUNCTIONAL DEPENDENCIES:
Student table:
  - StudentID ‚Üí ?
  - Email ‚Üí ?

Course table:
  - CourseID ‚Üí ?

Enrollment table:
  - {StudentID, CourseID} ‚Üí ?

ER DIAGRAM:
[Include your diagram here]</code></pre>
<p><strong>Practice Deliverable:</strong> Analysis document (2-3 pages)
with ER diagram</p>
<hr />
<h4 id="part-2-normalization-implementation">Part 2: Normalization
Implementation</h4>
<p><strong>Progressive Normalization:</strong></p>
<p><strong>Step 1: Unnormalized Starting Point</strong> Show all data in
one large table with repeating groups</p>
<p><strong>Step 2: First Normal Form (1NF)</strong> - Eliminate
repeating groups - Ensure atomic values - Identify primary key</p>
<p><strong>Step 3: Second Normal Form (2NF)</strong> - Eliminate partial
dependencies (if any) - Show before/after tables</p>
<p><strong>Step 4: Third Normal Form (3NF)</strong> - Eliminate
transitive dependencies (if any) - Show before/after tables</p>
<p><strong>Step 5: BCNF Analysis</strong> - Check for non-superkey
determinants - Justify whether BCNF is needed (likely NOT for this
simple scenario)</p>
<p><strong>Design Justification:</strong> For each step, answer: - What
problem did this normalization fix? - What anomalies were prevented? -
Why did you stop at 3NF (or continue to BCNF)?</p>
<p><strong>Practice Deliverable:</strong> Normalization document (3-4
pages) showing each step with before/after tables</p>
<hr />
<h4 id="part-3-sql-implementation">Part 3: SQL Implementation</h4>
<p><strong>Complete DDL:</strong></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Create all tables with appropriate data types</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> Student (</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    StudentID <span class="dt">INT</span> <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    FirstName <span class="dt">VARCHAR</span>(<span class="dv">50</span>) <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    LastName <span class="dt">VARCHAR</span>(<span class="dv">50</span>) <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    Email <span class="dt">VARCHAR</span>(<span class="dv">100</span>) <span class="kw">UNIQUE</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    EnrollmentDate <span class="dt">DATE</span> <span class="kw">NOT</span> <span class="kw">NULL</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> Course (</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    CourseID <span class="dt">INT</span> <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    CourseName <span class="dt">VARCHAR</span>(<span class="dv">100</span>) <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    InstructorName <span class="dt">VARCHAR</span>(<span class="dv">100</span>) <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    Price <span class="dt">DECIMAL</span>(<span class="dv">10</span>,<span class="dv">2</span>) <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">Category</span> <span class="dt">VARCHAR</span>(<span class="dv">50</span>) <span class="kw">NOT</span> <span class="kw">NULL</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> Enrollment (</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>    StudentID <span class="dt">INT</span>,</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>    CourseID <span class="dt">INT</span>,</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>    EnrollmentDate <span class="dt">DATE</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>    ProgressPercent <span class="dt">INT</span> <span class="kw">DEFAULT</span> <span class="dv">0</span>,</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>    CompletedFlag <span class="dt">BOOLEAN</span> <span class="kw">DEFAULT</span> <span class="kw">FALSE</span>,</span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">PRIMARY</span> <span class="kw">KEY</span> (StudentID, CourseID),</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FOREIGN</span> <span class="kw">KEY</span> (StudentID) <span class="kw">REFERENCES</span> Student(StudentID),</span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FOREIGN</span> <span class="kw">KEY</span> (CourseID) <span class="kw">REFERENCES</span> Course(CourseID)</span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>);</span></code></pre></div>
<p><strong>Sample Data:</strong> Insert at least 5 students, 5 courses,
and 10 enrollments</p>
<p><strong>Required Queries (provide SQL + results):</strong> 1. List
all students enrolled in a specific course 2. Show all courses a student
is taking with their progress 3. Calculate average progress across all
enrollments for a course 4. Find students who have completed at least 3
courses 5. List courses with no enrollments</p>
<p><strong>Practice Deliverable:</strong> SQL file with complete schema
+ sample data + 5 queries</p>
<hr />
<h3 id="practice-tips">Practice Tips</h3>
<p><strong>Analysis Phase:</strong> - üìä Start simple - only 3 entities
means you can be thorough - üé® Draw ER diagram by hand first, then
digitize - ‚úÖ Review your work against the normalization rules</p>
<p><strong>Normalization Phase:</strong> - üìù Show your work - document
each step clearly - üîç Use the 4-step process from Class 2 for finding
transitive dependencies - üí° Justify your decisions - ‚ÄúI stopped at 3NF
because there are no BCNF violations‚Äù - ‚ö†Ô∏è Common mistake: Forgetting
that Enrollment needs a composite key {StudentID, CourseID}</p>
<p><strong>Implementation Phase:</strong> - üíª Test your SQL - actually
run it in a database (MySQL, PostgreSQL, SQLite) - üêõ Check your
constraints - try to insert duplicate enrollments (should fail!) - üìö
Add comments to your SQL explaining your design decisions</p>
<p><strong>Common Pitfalls to Avoid:</strong> 1. ‚ùå Putting student name
in Enrollment table (violates 3NF - transitive dependency!) 2. ‚ùå
Forgetting foreign key constraints 3. ‚ùå Not using composite primary key
for Enrollment 4. ‚ùå Skipping normalization steps - show your work!</p>
<p><strong>Self-Check Questions:</strong> - ‚úì Can I insert a new student
without enrolling them in a course? (Should be YES) - ‚úì Can I delete a
course without losing student data? (Should be YES) - ‚úì If I update a
course price, do I update it in one place? (Should be YES) - ‚úì Are all
my non-key attributes fully dependent on the primary key? (Should be
YES)</p>
<hr />
<h2 id="class-wrap-up-2-minutes">Class Wrap-Up (2 minutes)</h2>
<p><strong>What we covered today:</strong></p>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 29%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr>
<th>Normal Form</th>
<th>Eliminates</th>
<th>Your Action</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>3NF</strong></td>
<td>Transitive dependencies</td>
<td><strong>Use this as your default!</strong></td>
</tr>
<tr>
<td><strong>BCNF</strong></td>
<td>Non-superkey determinants</td>
<td>Rare - only if 3NF causes problems</td>
</tr>
<tr>
<td><strong>4NF</strong></td>
<td>Multi-valued dependencies</td>
<td>Recognize independent facts</td>
</tr>
<tr>
<td><strong>5NF</strong></td>
<td>Join dependencies</td>
<td>Almost never needed</td>
</tr>
</tbody>
</table>
<p><strong>Key Decision Rule:</strong> 1. <strong>Start with
3NF</strong> - solves 95% of problems 2. <strong>Check</strong>: Am I
having anomalies? If NO ‚Üí Stop! 3. <strong>If YES</strong>: Consider
BCNF/4NF (rare cases)</p>
<p><strong>Modern Reality:</strong> - Normalization = data integrity -
Denormalization = performance (when measured and justified) - Hybrid
approaches = best of both worlds</p>
<p><strong>Next steps:</strong> - Optional practice exercise available
(online course platform scenario) - Apply these concepts in your
PostgreSQL projects - Ask questions if anything is unclear!</p>
<p><strong>Questions?</strong></p>
