<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Database Normalization: Class 1 â€“ Foundations</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="canvas-style.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Database Normalization: Class 1 â€“ Foundations</h1>
</header>
<h1 id="database-normalization-class-1-foundations">Database
Normalization: Class 1 â€“ Foundations</h1>
<h2 id="building-better-database-schemas-1nf-2nf">Building Better
Database Schemas (1NF â†’ 2NF)</h2>
<h3 id="class-overview-75-minutes">Class Overview (75 minutes)</h3>
<p><strong>How to use this document:</strong> - <strong>Before
class:</strong> Read through Key Concepts section, try the checkpoint
questions - <strong>During class:</strong> Follow along, add your own
notes and examples in margins - <strong>After class:</strong> Review
checkpoints, complete practice problems, use for homework reference -
<strong>Time allocations:</strong> These show both in-class pacing and
suggested study time for each section</p>
<table>
<thead>
<tr>
<th>Segment</th>
<th>Topic</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Introduction &amp; Motivation</td>
<td>12 min</td>
</tr>
<tr>
<td>2</td>
<td>Key Concepts (with checkpoints)</td>
<td>25 min</td>
</tr>
<tr>
<td>3</td>
<td>First Normal Form (1NF)</td>
<td>10 min</td>
</tr>
<tr>
<td>4</td>
<td>Second Normal Form (2NF)</td>
<td>18 min</td>
</tr>
<tr>
<td>5</td>
<td>In-Class Practice (Examples 1-2)</td>
<td>25 min</td>
</tr>
<tr>
<td>6</td>
<td>Practice Review &amp; Discussion</td>
<td>8 min</td>
</tr>
<tr>
<td>7</td>
<td>Assignment Overview &amp; Exit Ticket</td>
<td>7 min</td>
</tr>
</tbody>
</table>
<p><em>Note: Class timing is approximate and will flex based on
discussion and questions. Focus on understanding concepts rather than
rushing through examples.</em></p>
<hr />
<h2 id="learning-objectives">Learning Objectives</h2>
<p>By the end of this lesson, you will be able to:</p>
<ol type="1">
<li><strong>Identify</strong> the three types of database anomalies
(update, insertion, deletion) in unnormalized tables</li>
<li><strong>Define</strong> functional dependencies and use the notation
X â†’ Y</li>
<li><strong>Determine</strong> appropriate primary keys, including
composite (multi-part) keys</li>
<li><strong>Recognize</strong> violations of First Normal Form (1NF) and
Second Normal Form (2NF)</li>
<li><strong>Decompose</strong> tables into 2NF by eliminating partial
dependencies</li>
<li><strong>Explain</strong> how normalization prevents specific
database problems</li>
</ol>
<hr />
<p>ğŸ“– <strong>KEY TERMS FOR TODAY</strong> - <strong>Atomic
value</strong>: A single value (not multiple values in one cell, like
â€œ555-1234, 555-5678â€) - <strong>Functional dependency</strong>: If you
know value A, you can look up value B (like StudentID â†’ StudentName) -
<strong>Primary key (PK)</strong>: A column (or set of columns) that
uniquely identifies each row in a table - <strong>Foreign key
(FK)</strong>: A column in one table that references the primary key of
another table, creating a link between them - <strong>Composite
key</strong>: A primary key made from 2 or more columns working together
- <strong>Partial dependency</strong>: When data depends on only PART of
a composite key (this causes problems!) - <strong>Decompose</strong>:
Break apart / split up a table into multiple smaller tables</p>
<hr />
<h2 id="introduction-why-normalize-data">Introduction: Why Normalize
Data?</h2>
<p>Youâ€™ve learned to design ERDs showing entities and relationships.
Today we learn how to organize data <strong>within</strong> those
entities to prevent common database problems.</p>
<h3 id="the-problem-database-anomalies">The Problem: Database
Anomalies</h3>
<p><strong>Example: Unnormalized Student Registration Table</strong></p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 12%" />
<col style="width: 15%" />
<col style="width: 19%" />
<col style="width: 9%" />
<col style="width: 18%" />
<col style="width: 8%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr>
<th>StudentID</th>
<th>StudentName</th>
<th>StudentEmail</th>
<th>PhoneNumbers</th>
<th>CourseID</th>
<th>CourseName</th>
<th>Credits</th>
<th>Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>John Smith</td>
<td>john@email.com</td>
<td>555-1234, 555-5678</td>
<td>CS101</td>
<td>Intro Programming</td>
<td>3</td>
<td>A</td>
</tr>
<tr>
<td>101</td>
<td>John Smith</td>
<td>john@email.com</td>
<td>555-1234, 555-5678</td>
<td>MATH201</td>
<td>Calculus I</td>
<td>4</td>
<td>B</td>
</tr>
<tr>
<td>102</td>
<td>Jane Doe</td>
<td>jane@email.com</td>
<td>555-9999</td>
<td>CS101</td>
<td>Intro Programming</td>
<td>3</td>
<td>A</td>
</tr>
</tbody>
</table>
<p><strong>Three Critical Problems:</strong> 1. <strong>Update
anomaly</strong>: Changing Johnâ€™s email requires updating multiple rows
2. <strong>Insertion anomaly</strong>: Canâ€™t add a new course without a
student enrollment 3. <strong>Deletion anomaly</strong>: If Jane drops
CS101, we lose course information</p>
<p>â¡ï¸ <strong>Solution: Normalization</strong> â€“ A systematic process to
organize data efficiently</p>
<hr />
<h2 id="key-concepts">Key Concepts</h2>
<h3 id="functional-dependencies">Functional Dependencies</h3>
<p><strong>Simple explanation:</strong> When you know one piece of
information (A), you can find another piece of information (B).</p>
<p><strong>Real-world analogy:</strong> Think of a phone book: - If you
know someoneâ€™s <strong>name</strong>, you can find their <strong>phone
number</strong> - The name DETERMINES the phone number youâ€™ll find - We
write this as: <code>Name â†’ PhoneNumber</code></p>
<p><strong>Formal notation</strong>: <code>X â†’ Y</code> means â€œX
determines Yâ€ or â€œIf you know X, you can find Yâ€</p>
<p><strong>In our student registration example:</strong> -
<code>StudentID â†’ StudentName, StudentEmail</code> â†³ <em>If you know the
StudentID (101), you can find the studentâ€™s name (John Smith) and
email</em></p>
<ul>
<li><p><code>CourseID â†’ CourseName, Credits</code> â†³ <em>If you know the
CourseID (CS101), you can find the course name and credit
hours</em></p></li>
<li><p><code>{StudentID, CourseID} â†’ Grade</code> â†³ <em>You need BOTH
StudentID AND CourseID together to find the grade (Johnâ€™s grade in
CS101)</em></p></li>
</ul>
<p><strong>Key insight:</strong> Functional dependencies help us
understand what information â€œbelongs togetherâ€</p>
<hr />
<p>âœ‹ <strong>CHECKPOINT #1: Check Your Understanding</strong></p>
<p>Before moving on, make sure you can answer: 1. In the notation
<code>CourseID â†’ CourseName</code>, which value do you need to know
first? (Answer: CourseID) 2. If <code>ISBN â†’ BookTitle</code>, and you
know the ISBN is â€œ978-0-13-467626-6â€, what can you find? (Answer: The
book title) 3. True or False: Functional dependencies are just about
which columns relate to each other. (Answer: True!)</p>
<p><em>Take 30 seconds to write one functional dependency from a
database YOU use (social media, email, shopping, etc.)</em></p>
<hr />
<h3 id="primary-keys">Primary Keys</h3>
<p>A <strong>Primary Key (PK)</strong> uniquely identifies each record.
Letâ€™s think about our data: - Can StudentID alone identify a row? No -
one student has multiple rows (for different courses) - Can CourseID
alone identify a row? No - one course has multiple rows (for different
students) - What about StudentID + CourseID together? Yes! Each
combination appears only once</p>
<p>This tells us our table <strong>should have</strong> a
<strong>composite primary key</strong>:
<code>{StudentID, CourseID}</code></p>
<p>âš ï¸ <strong>MISCONCEPTION ALERT:</strong> Many students think primary
keys must always be a single field. Not true! Composite keys (made from
2 or more fields) are very common, especially in tables that track
relationships.</p>
<hr />
<h3 id="partial-dependencies">Partial Dependencies</h3>
<p><strong>Why this matters:</strong> Once we have a composite key, we
need to check if ALL data really needs the WHOLE key.</p>
<p><strong>Definition:</strong> A <strong>partial dependency</strong>
happens when an attribute depends on <strong>only part</strong> of a
composite key (not the whole thing).</p>
<p><strong>Visual Example:</strong> Letâ€™s look at our table with
composite key <code>{StudentID, CourseID}</code>:</p>
<pre><code>Question: Does StudentName need BOTH StudentID AND CourseID to be found?
Answer: No! StudentName only needs StudentID.
         â†³ This is a PARTIAL dependency (only uses part of the key)

Question: Does CourseName need BOTH StudentID AND CourseID to be found?
Answer: No! CourseName only needs CourseID.
         â†³ This is also a PARTIAL dependency

Question: Does Grade need BOTH StudentID AND CourseID to be found?
Answer: YES! You need to know which student AND which course to find the grade.
         â†³ This is a FULL dependency âœ“ (uses the entire key)</code></pre>
<p><strong>Summary for our table:</strong> -
<code>StudentID â†’ StudentName, StudentEmail</code> â†
<strong>partial</strong> dependency (only uses part of key) -
<code>CourseID â†’ CourseName, Credits</code> â† <strong>partial</strong>
dependency (only uses part of key) -
<code>{StudentID, CourseID} â†’ Grade</code> â† <strong>full</strong>
dependency âœ“ (uses entire key)</p>
<p><strong>The problem:</strong> Partial dependencies cause data to
repeat unnecessarily, creating all those anomalies we saw earlier!</p>
<p><strong>Important rule:</strong> Partial dependencies can ONLY exist
when you have a composite key. A table with a single-field primary key
cannot have partial dependencies.</p>
<hr />
<p>âœ‹ <strong>CHECKPOINT #2: Check Your Understanding</strong></p>
<p>Before moving on, make sure you can answer: 1. Can a table with a
single-field primary key (like StudentID alone) have partial
dependencies? (Answer: No! You need a composite key for partial
dependencies to exist) 2. In a table with composite key
<code>{OrderID, ProductID}</code>, if <code>ProductPrice</code> depends
only on <code>ProductID</code>, is this a partial or full dependency?
(Answer: Partial - it only needs part of the key) 3. Why are partial
dependencies a problem? (Answer: They cause data to repeat
unnecessarily, leading to anomalies)</p>
<p>â¸ï¸ <strong>Pause here.</strong> Partial dependencies are tricky!
Re-read lines 112-141 if needed before moving on.</p>
<hr />
<h2 id="first-normal-form-1nf">First Normal Form (1NF)</h2>
<h3 id="requirements">Requirements</h3>
<ol type="1">
<li><strong>Atomic values</strong> â€“ no multi-valued fields</li>
<li><strong>No repeating groups</strong></li>
<li><strong>Each row is unique</strong></li>
</ol>
<h3 id="converting-to-1nf">Converting to 1NF</h3>
<p><strong>Before (Unnormalized):</strong> | StudentID | StudentName |
StudentEmail | PhoneNumbers | CourseID | CourseName | Credits | Grade |
|â€”â€”â€”â€“|â€”â€”â€”â€”-|â€”â€”â€”â€”â€”-|â€”â€”â€”â€”â€”â€”â€“|â€”â€”â€”-|â€”â€”â€”â€”â€”â€”-|â€”â€”â€”|â€”â€”-| | 101 | John Smith |
john@email.com | 555-1234, 555-5678 | CS101 | Intro Programming | 3 | A
| | 101 | John Smith | john@email.com | 555-1234, 555-5678 | MATH201 |
Calculus I | 4 | B | | 102 | Jane Doe | jane@email.com | 555-9999 |
CS101 | Intro Programming | 3 | A |</p>
<p><strong>Violation</strong>: The PhoneNumbers column contains
<strong>multiple values</strong> (non-atomic data)</p>
<p><strong>After (1NF) - Separating Phone Numbers:</strong> | StudentID
| StudentName | StudentEmail | PhoneNumber | CourseID | CourseName |
Credits | Grade | |â€”â€”â€”â€“|â€”â€”â€”â€”-|â€”â€”â€”â€”â€”-|â€”â€”â€”â€”-|â€”â€”â€”-|â€”â€”â€”â€”â€”â€”-|â€”â€”â€”|â€”â€”-| | 101 |
John Smith | john@email.com | 555-1234 | CS101 | Intro Programming | 3 |
A | | 101 | John Smith | john@email.com | 555-1234 | MATH201 | Calculus
I | 4 | B | | 101 | John Smith | john@email.com | 555-5678 | CS101 |
Intro Programming | 3 | A | | 101 | John Smith | john@email.com |
555-5678 | MATH201 | Calculus I | 4 | B | | 102 | Jane Doe |
jane@email.com | 555-9999 | CS101 | Intro Programming | 3 | A |</p>
<p>ğŸ” <strong>Important Observation</strong>: Weâ€™ve accomplished our 1NF
goal - all values are now atomic!</p>
<p><strong>What 1NF fixed:</strong> âœ… - âœ… No more multi-valued fields
(phones are now individual rows) - âœ… All values are atomic (single
values only) - âœ… We can now uniquely identify each row with
<code>{StudentID, PhoneNumber, CourseID}</code></p>
<p><strong>What we notice:</strong> - Johnâ€™s name/email appear 4 times
instead of 2 (once per phone-course combination) - Course info
duplicates for each student phone number - The composite key has three
parts</p>
<p><strong>Is this a problem?</strong> Yes - we still have redundancy!
But thatâ€™s exactly what the NEXT step (2NF) will fix.</p>
<p><strong>Understanding the process:</strong> ğŸ¯ - <strong>1NF</strong>
= Make values atomic (we just did this!) - <strong>2NF</strong> = Remove
partial dependencies (coming up next - this will eliminate the
redundancy!) - <strong>3NF</strong> = Remove transitive dependencies
(Class 2)</p>
<p><strong>Think of it like building a house:</strong> - 1NF =
Foundation (structure is in place) - 2NF = Framing (organize into proper
rooms) - 3NF = Finishing work (polish and optimize)</p>
<p><strong>Each step builds on the previous one.</strong> Letâ€™s see how
2NF fixes our redundancy issues!</p>
<hr />
<h2 id="second-normal-form-2nf">Second Normal Form (2NF)</h2>
<h3 id="requirements-1">Requirements</h3>
<ol type="1">
<li>Already in 1NF</li>
<li><strong>No partial dependencies</strong> â€“ all non-key attributes
depend on the <strong>entire</strong> primary key</li>
</ol>
<h3 id="analyzing-our-1nf-table">Analyzing Our 1NF Table</h3>
<p>With composite key <code>{StudentID, PhoneNumber, CourseID}</code>,
we have partial dependencies: -
<code>StudentID â†’ StudentName, StudentEmail</code> (doesnâ€™t need
PhoneNumber or CourseID) - <code>CourseID â†’ CourseName, Credits</code>
(doesnâ€™t need StudentID or PhoneNumber) - Only <code>Grade</code>
depends on the student-course combination</p>
<h3 id="solution-decompose-into-separate-tables">Solution: Decompose
into Separate Tables</h3>
<p>Break apart the data so each table has a clear, simple purpose:</p>
<h4 id="nf-table-structure">2NF Table Structure</h4>
<p><strong>Visual Concept: One Big Messy Table â†’ Four Small Clean
Tables</strong></p>
<pre><code>                    [Original Messy Table]
                     All data mixed together
                              |
                              | Decompose
                              â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â†“              â†“              â†“              â†“
    [STUDENT]    [STUDENT_PHONE]  [COURSE]     [ENROLLMENT]
  Student info    Phone numbers   Course info   Who takes what</code></pre>
<p><strong>The Four Tables:</strong></p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 22%" />
<col style="width: 18%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr>
<th><strong>STUDENT</strong></th>
<th><strong>STUDENT_PHONE</strong></th>
<th><strong>COURSE</strong></th>
<th><strong>ENROLLMENT</strong> <em>(bridge table)</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>StudentID (PK)</td>
<td>StudentID (FK)</td>
<td>CourseID (PK)</td>
<td>StudentID (FK)</td>
</tr>
<tr>
<td>StudentName</td>
<td>PhoneNumber</td>
<td>CourseName</td>
<td>CourseID (FK)</td>
</tr>
<tr>
<td>StudentEmail</td>
<td></td>
<td>Credits</td>
<td>Grade</td>
</tr>
</tbody>
</table>
<p><strong>How the data flows:</strong> 1. <strong>STUDENT</strong>
stores info about students (name, email) - ONE row per student 2.
<strong>STUDENT_PHONE</strong> stores phone numbers - MULTIPLE rows per
student if they have multiple phones 3. <strong>COURSE</strong> stores
info about courses (name, credits) - ONE row per course 4.
<strong>ENROLLMENT</strong> connects students to courses and stores the
grade - ONE row per student-course combination</p>
<p><strong>Note:</strong> The ENROLLMENT tableâ€™s primary key is
<code>{StudentID, CourseID}</code> - the same composite key we
identified earlier, but now itâ€™s in its own focused table! This is
called a <strong>bridge table</strong> because it bridges the
many-to-many relationship between students and courses.</p>
<h3 id="relational-schema-shorthand-notation">Relational Schema
(Shorthand Notation)</h3>
<p><strong>Legend:</strong> <code>[PK]</code> = Primary Key |
<code>[FK]</code> = Foreign Key | <code>â†’</code> = â€œreferencesâ€</p>
<p><em>Note: This notation is commonly used in textbooks and
documentation. You donâ€™t need to memorize this format, but you should be
able to read it.</em></p>
<pre><code>STUDENT(StudentID [PK], StudentName, StudentEmail)
STUDENT_PHONE(StudentID [FK], PhoneNumber)
COURSE(CourseID [PK], CourseName, Credits)
ENROLLMENT(StudentID [FK], CourseID [FK], Grade)
    Primary Key: {StudentID, CourseID}

FK STUDENT_PHONE.StudentID â†’ STUDENT.StudentID
FK ENROLLMENT.StudentID â†’ STUDENT.StudentID
FK ENROLLMENT.CourseID â†’ COURSE.CourseID</code></pre>
<p><strong>What this means in plain English:</strong> - The STUDENT
table has StudentID as its primary key - The STUDENT_PHONE tableâ€™s
StudentID is a foreign key that points back to the STUDENT table - The
ENROLLMENT table uses BOTH StudentID and CourseID together as its
composite primary key - Both fields in ENROLLMENT are also foreign keys
linking to other tables</p>
<h3 id="why-this-works">Why This Works</h3>
<p>âœ… Each table represents <strong>one concept</strong> âœ… No more
redundancy (Johnâ€™s name stored once) âœ… Can add students, courses, or
phones independently âœ… Updates affect only one row âœ… The composite key
lives where it belongs - in the relationship table</p>
<p>âš ï¸ <strong>MISCONCEPTION ALERT:</strong> Students sometimes think
â€œMore tables is always better.â€ Not true! We stop at 2NF when weâ€™ve
eliminated partial dependencies. Over-normalizing can actually make
databases harder to use. (Weâ€™ll learn about 3NF and when to stop next
class.)</p>
<hr />
<h2 id="in-class-practice">ğŸ§© In-Class Practice</h2>
<h3 id="how-to-approach-normalization-problems">How to Approach
Normalization Problems</h3>
<p><strong>Follow these steps for each problem:</strong></p>
<pre><code>STEP 1: Find the Composite Key
â”œâ”€ Question: &quot;What combination of fields makes each row unique?&quot;
â”œâ”€ Strategy: Look for what appears only once per row
â””â”€ Test: Does this field combo appear more than once? If yes, keep adding fields

STEP 2: List All Functional Dependencies
â”œâ”€ Question: &quot;What determines what?&quot;
â”œâ”€ Strategy: For each field, ask: &quot;Does knowing X let me find Y?&quot;
â””â”€ Write them as: X â†’ Y

STEP 3: Identify Partial Dependencies
â”œâ”€ Question: &quot;Does this field need the WHOLE composite key or just part of it?&quot;
â”œâ”€ Strategy: Check each attribute against each part of the composite key
â””â”€ Mark which dependencies are PARTIAL (use only part of key)

STEP 4: Create Tables
â”œâ”€ Make one table for each PART of the composite key
â”œâ”€ Move attributes that depend on only that part
â”œâ”€ Keep fully-dependent attributes in a relationship table
â””â”€ Don&#39;t forget: Each table needs a primary key!

STEP 5: Check Your Work
â”œâ”€ Does each table represent ONE concept?
â”œâ”€ Is data stored only ONCE (no redundancy)?
â””â”€ Can you add/update/delete without anomalies?</code></pre>
<p><strong>When Youâ€™re Stuck:</strong> - ğŸ” Not sure what the key is?
Look for what combination appears only once - ğŸ” Canâ€™t find partial
dependencies? Ask: â€œDoes this field need ALL parts of the key?â€ - ğŸ”
Donâ€™t know how many tables to create? Usually: one per key part + one
relationship table</p>
<hr />
<p><strong>Instructions</strong>: Work in pairs. For each example: 1.
Identify what the composite primary key should be 2. Find functional
dependencies 3. Spot partial dependencies 4. Sketch the 2NF
decomposition</p>
<h3 id="example-1-library-book-loans">Example 1: Library Book Loans</h3>
<pre><code>Table: LIBRARY_LOANS
MemberID | MemberName | MemberPhone | BookID | BookTitle        | Author    | DueDate | Fine
201      | Alice Chen | 555-1010    | B01    | Database Systems | C.J. Date | 10/15   | 2.50
201      | Alice Chen | 555-1010    | B02    | SQL Basics       | Elmasri   | 10/22   | 0.00
202      | Ben Ortiz  | 555-2020    | B01    | Database Systems | C.J. Date | 10/18   | 1.00</code></pre>
<p><strong>Guided Help:</strong> - <strong>Finding the key:</strong>
Look at rows 1 and 3. Both have BookID = B01, but theyâ€™re different
loans (different members). Now look at rows 1 and 2. Both have MemberID
= 201, but theyâ€™re different loans (different books). So you need BOTH
MemberID AND BookID together to identify a unique loan. -
<strong>Partial dependencies:</strong> Does MemberName need both
MemberID and BookID? No, just MemberID! Does BookTitle need both? No,
just BookID! These are partial dependencies. - <strong>Expected
tables:</strong> You should create 3 tables (MEMBER, BOOK, LOAN)</p>
<h3 id="example-2-employee-project-hours">Example 2: Employee Project
Hours</h3>
<pre><code>Table: PROJECT_ASSIGNMENTS
EmpID | EmpName  | EmpDept | ProjectID | ProjectName | ProjectMgr | HoursWorked
501   | Dana Lee | HR      | P01       | Website     | Smith      | 10
501   | Dana Lee | HR      | P02       | Database    | Jones      | 5
502   | Omar Ali | Finance | P01       | Website     | Smith      | 8</code></pre>
<p><strong>Guided Help:</strong> - <strong>Finding the key:</strong> Can
you have the same employee on multiple projects? Yes (Dana is on P01 and
P02). Can you have multiple employees on the same project? Yes (Dana and
Omar both on P01). So the key must be: <code>{EmpID, ProjectID}</code> -
<strong>Partial dependencies:</strong> Think about EmpName and EmpDept -
do they change based on which project? No! They only depend on EmpID.
What about ProjectName and ProjectMgr? They only depend on ProjectID. -
<strong>Expected tables:</strong> You should create 3 tables (EMPLOYEE,
PROJECT, ASSIGNMENT)</p>
<hr />
<h2 id="practice-review-discussion">Practice Review &amp;
Discussion</h2>
<p>Letâ€™s review Example 1 together: - <strong>Composite Key Should
Be</strong>: <code>{MemberID, BookID}</code> - <strong>Partial
Dependencies</strong>: - <code>MemberID â†’ MemberName, MemberPhone</code>
- <code>BookID â†’ BookTitle, Author</code> -
<code>{MemberID, BookID} â†’ DueDate, Fine</code> (full dependency) -
<strong>2NF Tables</strong>: - MEMBER(MemberID, MemberName, MemberPhone)
- BOOK(BookID, BookTitle, Author) - LOAN(MemberID, BookID, DueDate,
Fine)</p>
<hr />
<h2 id="assignment-overview">Assignment Overview</h2>
<h3 id="homework-normalize-studentdata.xlsx">Homework: Normalize
StudentData.xlsx</h3>
<p><strong>Part 1: Analysis (30 pts)</strong> - Identify what the
primary key should be - Find all functional dependencies - Spot partial
dependencies</p>
<p><strong>Part 2: Normalization (60 pts)</strong> - Convert to 1NF (20
pts) - Convert to 2NF (40 pts) - Show all primary/foreign keys</p>
<p><strong>Part 3: Reflection (10 pts)</strong> - What problems did 1NF
solve? - What problems did 2NF solve? - What anomalies are
prevented?</p>
<p><strong>Submission</strong>:
<code>LastName_FirstName_Normalization1.xlsx</code>
<strong>Due</strong>: Next class</p>
<hr />
<h2 id="exit-ticket-required---turn-in-before-leaving">âœ‹ EXIT TICKET
(Required - Turn in Before Leaving)</h2>
<p><strong>Answer these 3 questions on an index card or
paper:</strong></p>
<ol type="1">
<li><p><strong>Explain in your own words:</strong> Whatâ€™s the difference
between 1NF and 2NF? (2-3 sentences)</p></li>
<li><p><strong>Quick application:</strong> In a table with composite key
<code>{StudentID, ClubID}</code>, you find that
<code>ClubMeetingRoom</code> depends only on <code>ClubID</code>. Is
this a partial or full dependency?</p></li>
<li><p><strong>Reflection:</strong> Whatâ€™s still confusing about
normalization? What do you need to review before next class?</p></li>
</ol>
<p><em>Your instructor will review these before next class to address
common confusion points.</em></p>
<hr />
<h2 id="key-takeaways">Key Takeaways</h2>
<ul>
<li><strong>1NF</strong>: Makes values atomic, eliminates repeating
groups</li>
<li><strong>2NF</strong>: Removes partial dependencies by decomposing
tables</li>
<li><strong>Composite keys</strong> often indicate a need for
decomposition</li>
<li><strong>Each table = one concept</strong></li>
<li><strong>Bridge tables</strong> handle many-to-many
relationships</li>
</ul>
<h2 id="next-class">Next Class</h2>
<p><strong>Third Normal Form (3NF)</strong> â€“ Weâ€™ll tackle transitive
dependencies and learn when to stop normalizing.</p>
<hr />
<h2 id="quick-reference-card">Quick Reference Card</h2>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 27%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr>
<th>Normal Form</th>
<th>Focus</th>
<th>Key Question</th>
</tr>
</thead>
<tbody>
<tr>
<td>1NF</td>
<td>Atomic values</td>
<td>â€œAre all values single?â€</td>
</tr>
<tr>
<td>2NF</td>
<td>Partial dependencies</td>
<td>â€œDo all attributes depend on the WHOLE key?â€</td>
</tr>
</tbody>
</table>
<p><strong>Remember:</strong> First identify what your key SHOULD be,
then check if all attributes depend on that entire key!</p>
</body>
</html>
