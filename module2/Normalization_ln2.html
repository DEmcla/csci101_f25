<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database Normalization: Class 2 ‚Äì Third Normal Form</title>
    <link rel="stylesheet" href="canvas-style.css">
</head>
<body>

<h1>Database Normalization: Class 2 ‚Äì Third Normal Form</h1>
<h2>Mastering 3NF: The Industry Standard</h2>

<h3>Class Overview (75 minutes)</h3>

<p><strong>How to use this document:</strong></p>
<ul>
<li><strong>Before class:</strong> Review 1NF/2NF concepts from Class 1, read through transitive dependencies section</li>
<li><strong>During class:</strong> Follow along, work through examples, note the decision-making process</li>
<li><strong>After class:</strong> Use checkpoints to verify understanding, complete practice problems</li>
<li><strong>Time allocations:</strong> These show both in-class pacing and suggested study time for each section</li>
</ul>

<table>
<thead>
<tr>
<th>Segment</th>
<th>Topic</th>
<th>Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2NF Retrieval Quiz &amp; Review</td>
<td>8 min</td>
</tr>
<tr>
<td>2</td>
<td>Third Normal Form (3NF) Introduction</td>
<td>20 min</td>
</tr>
<tr>
<td>3</td>
<td>In-Class Practice (2 examples)</td>
<td>20 min</td>
</tr>
<tr>
<td>4</td>
<td>Practice Review &amp; Discussion</td>
<td>8 min</td>
</tr>
<tr>
<td>5</td>
<td>Looking Ahead: Beyond 3NF</td>
<td>8 min</td>
</tr>
<tr>
<td>6</td>
<td>Practical Considerations &amp; Trade-offs</td>
<td>6 min</td>
</tr>
<tr>
<td>7</td>
<td>Assignment Introduction &amp; Exit Ticket</td>
<td>5 min</td>
</tr>
</tbody>
</table>

<p><em>Note: Class timing is approximate and will flex based on discussion and questions. Focus on mastering 3NF - that's the industry standard!</em></p>

<hr>

<h2>Learning Objectives</h2>

<p>By the end of this lesson, you will be able to:</p>

<ol>
<li><strong>Identify</strong> transitive dependencies in 2NF tables</li>
<li><strong>Explain</strong> the difference between 3NF and BCNF</li>
<li><strong>Decompose</strong> tables to achieve 3NF by eliminating transitive dependencies</li>
<li><strong>Recognize</strong> when BCNF is necessary versus when 3NF is sufficient</li>
<li><strong>Evaluate</strong> trade-offs between normalization levels and query complexity</li>
<li><strong>Decide</strong> when to stop normalizing based on practical considerations</li>
</ol>

<hr>

<p>üìñ <strong>KEY TERMS FOR TODAY</strong></p>
<ul>
<li><strong>Transitive dependency</strong>: When A ‚Üí B and B ‚Üí C, then A ‚Üí C indirectly (this causes problems!)</li>
<li><strong>Superkey</strong>: Any combination of attributes that uniquely identifies a row (could include extra fields)</li>
<li><strong>Determinant</strong>: The left side of a functional dependency (the part before the ‚Üí)</li>
<li><strong>BCNF (Boyce-Codd Normal Form)</strong>: Stricter version of 3NF - every determinant must be a superkey</li>
<li><strong>Denormalize</strong>: Intentionally add redundancy back for performance (we'll discuss when this makes sense)</li>
</ul>

<hr>

<h2>Quick Review: Where We've Been</h2>

<h3>1NF Solved:</h3>
<ul>
<li>‚úÖ Non-atomic values (multiple items in one field)</li>
<li>‚úÖ Repeating groups</li>
</ul>

<h3>2NF Solved:</h3>
<ul>
<li>‚úÖ Partial dependencies (non-key attributes depending on part of composite key)</li>
</ul>

<h3>Still Need to Solve:</h3>
<ul>
<li>‚ùå <strong>Transitive dependencies</strong> - indirect relationships through other attributes</li>
<li>‚ùå <strong>Complex key relationships</strong> - when 3NF isn't quite enough</li>
</ul>

<hr>

<p>‚úã <strong>CHECKPOINT #0: 2NF Retrieval Practice</strong> (5 minutes)</p>

<p>Before we build on 2NF, let's verify you remember the key concepts from Class 1:</p>

<p><strong>Quick Quiz</strong> (No grades - just checking understanding):</p>

<p><strong>1. Identify the composite key:</strong></p>
<table>
<thead>
<tr>
<th>OrderID</th>
<th>ProductID</th>
<th>ProductName</th>
<th>Quantity</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>P50</td>
<td>Laptop</td>
<td>2</td>
</tr>
<tr>
<td>1001</td>
<td>P51</td>
<td>Mouse</td>
<td>1</td>
</tr>
</tbody>
</table>

<p>Answer: <code>{OrderID, ProductID}</code> - need both to identify each row uniquely</p>

<p><strong>2. Is this a partial dependency?</strong></p>
<ul>
<li>Table key: <code>{OrderID, ProductID}</code></li>
<li>Dependency: <code>ProductID ‚Üí ProductName</code></li>
</ul>

<p>Answer: YES - ProductName depends on only PART of the composite key (ProductID), not the whole key</p>

<p><strong>3. How many tables after 2NF decomposition?</strong></p>
<p>Answer: 3 tables (ORDER, PRODUCT, ORDER_DETAIL)</p>

<p><strong>If you struggled with any of these, review Class 1 notes before continuing!</strong></p>

<hr>

<h2>Third Normal Form (3NF)</h2>

<h3>The Problem: Transitive Dependencies</h3>

<p>Even after achieving 2NF, we can still have problems. Let's extend our course table:</p>

<p><strong>Course Table (2NF, but has problems):</strong></p>

<table>
<thead>
<tr>
<th>CourseID</th>
<th>CourseName</th>
<th>Credits</th>
<th>InstructorID</th>
<th>InstructorName</th>
<th>InstructorOffice</th>
<th>InstructorPhone</th>
</tr>
</thead>
<tbody>
<tr>
<td>CS101</td>
<td>Intro Programming</td>
<td>3</td>
<td>I001</td>
<td>Dr. Johnson</td>
<td>Room 101</td>
<td>555-1234</td>
</tr>
<tr>
<td>MATH201</td>
<td>Calculus I</td>
<td>4</td>
<td>I002</td>
<td>Dr. Williams</td>
<td>Room 205</td>
<td>555-5678</td>
</tr>
<tr>
<td>CS201</td>
<td>Data Structures</td>
<td>4</td>
<td>I001</td>
<td>Dr. Johnson</td>
<td>Room 101</td>
<td>555-1234</td>
</tr>
</tbody>
</table>

<h3>Transitive Dependency Chain:</h3>

<p><strong>Visual Diagram:</strong></p>
<pre><code>[CourseID] ‚îÄ‚îÄ‚Üí [InstructorID] ‚îÄ‚îÄ‚Üí [InstructorName]
   DIRECT          BRIDGE            ENDPOINT

This is INDIRECT because to get from CourseID to InstructorName,
you have to "hop through" InstructorID as a bridge.
</code></pre>

<p><strong>The dependency chain:</strong></p>
<pre><code>CourseID ‚Üí InstructorID          (Course determines which instructor)
InstructorID ‚Üí InstructorName     (Instructor ID determines name)
InstructorID ‚Üí InstructorOffice   (Instructor ID determines office)

Therefore: CourseID ‚Üí InstructorName (indirectly, through InstructorID)
</code></pre>

<p><strong>The key insight:</strong> InstructorName doesn't depend directly on CourseID - it depends on InstructorID, which depends on CourseID. This is a <strong>transitive dependency</strong> (going through an intermediate attribute).</p>

<p><strong>Pattern to recognize:</strong> "Information about the information"</p>
<ul>
<li>CourseID tells you the InstructorID (information about the course)</li>
<li>InstructorName tells you about the instructor, NOT about the course</li>
<li>If you have "info about info" ‚Üí likely a transitive dependency!</li>
</ul>

<h3>Problems This Creates:</h3>

<ol>
<li><strong>Update Anomaly</strong>: If Dr. Johnson moves to Room 102, we must update multiple course records</li>
<li><strong>Insertion Anomaly</strong>: Can't add new instructor information without assigning them to a course</li>
<li><strong>Deletion Anomaly</strong>: If CS201 is cancelled, we lose Dr. Johnson's office information</li>
</ol>

<p>‚ö†Ô∏è <strong>Sound familiar?</strong> These are the same three anomalies from Class 1! Transitive dependencies cause the same problems that partial dependencies did.</p>

<hr>

<h3>3NF Requirements:</h3>

<ol>
<li>‚úÖ Table is in 2NF</li>
<li>‚úÖ No transitive dependencies exist</li>
<li>‚úÖ Every non-key attribute depends <strong>directly</strong> on the primary key (not through other attributes)</li>
</ol>

<p><strong>Simple test:</strong> Can you say "A depends on B, and B depends on the primary key"? If yes, you have a transitive dependency!</p>

<hr>

<h3>3NF Solution: Separate the Entities</h3>

<p><strong>Course Table (3NF):</strong></p>

<table>
<thead>
<tr>
<th>CourseID</th>
<th>CourseName</th>
<th>Credits</th>
<th>InstructorID</th>
</tr>
</thead>
<tbody>
<tr>
<td>CS101</td>
<td>Intro Programming</td>
<td>3</td>
<td>I001</td>
</tr>
<tr>
<td>MATH201</td>
<td>Calculus I</td>
<td>4</td>
<td>I002</td>
</tr>
<tr>
<td>CS201</td>
<td>Data Structures</td>
<td>4</td>
<td>I001</td>
</tr>
</tbody>
</table>

<p><strong>Instructor Table (New):</strong></p>

<table>
<thead>
<tr>
<th>InstructorID</th>
<th>InstructorName</th>
<th>InstructorOffice</th>
<th>InstructorPhone</th>
</tr>
</thead>
<tbody>
<tr>
<td>I001</td>
<td>Dr. Johnson</td>
<td>Room 101</td>
<td>555-1234</td>
</tr>
<tr>
<td>I002</td>
<td>Dr. Williams</td>
<td>Room 205</td>
<td>555-5678</td>
</tr>
</tbody>
</table>

<h3>Benefits:</h3>

<ul>
<li>‚úÖ <strong>Update once</strong>: Change Dr. Johnson's office in one place</li>
<li>‚úÖ <strong>Add instructors</strong>: Can add instructor info without courses</li>
<li>‚úÖ <strong>Delete safely</strong>: Removing a course doesn't lose instructor data</li>
</ul>

<hr>

<h3>Complete 3NF Schema:</h3>

<p><strong>Visual Concept: Four Clean Tables Working Together</strong></p>

<pre><code>    [STUDENT] ----‚Üí [ENROLLMENT] ‚Üê---- [COURSE] ----‚Üí [INSTRUCTOR]
   Student info    Bridge table      Course info     Instructor info
</code></pre>

<p><strong>Student Table:</strong></p>

<table>
<thead>
<tr>
<th>StudentID</th>
<th>StudentName</th>
<th>StudentEmail</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>John Smith</td>
<td>john@email.com</td>
</tr>
<tr>
<td>102</td>
<td>Jane Doe</td>
<td>jane@email.com</td>
</tr>
</tbody>
</table>

<p><strong>Instructor Table:</strong></p>

<table>
<thead>
<tr>
<th>InstructorID</th>
<th>InstructorName</th>
<th>InstructorOffice</th>
<th>InstructorPhone</th>
</tr>
</thead>
<tbody>
<tr>
<td>I001</td>
<td>Dr. Johnson</td>
<td>Room 101</td>
<td>555-1234</td>
</tr>
<tr>
<td>I002</td>
<td>Dr. Williams</td>
<td>Room 205</td>
<td>555-5678</td>
</tr>
</tbody>
</table>

<p><strong>Course Table:</strong></p>

<table>
<thead>
<tr>
<th>CourseID</th>
<th>CourseName</th>
<th>Credits</th>
<th>InstructorID</th>
</tr>
</thead>
<tbody>
<tr>
<td>CS101</td>
<td>Intro Programming</td>
<td>3</td>
<td>I001</td>
</tr>
<tr>
<td>MATH201</td>
<td>Calculus I</td>
<td>4</td>
<td>I002</td>
</tr>
</tbody>
</table>

<p><strong>Enrollment Table:</strong></p>

<table>
<thead>
<tr>
<th>StudentID</th>
<th>CourseID</th>
<th>Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td>101</td>
<td>CS101</td>
<td>A</td>
</tr>
<tr>
<td>101</td>
<td>MATH201</td>
<td>B</td>
</tr>
<tr>
<td>102</td>
<td>CS101</td>
<td>A</td>
</tr>
</tbody>
</table>

<p><strong>Key Relationships:</strong></p>
<ul>
<li>Course.InstructorID ‚Üí Instructor.InstructorID (Foreign Key)</li>
<li>Enrollment.StudentID ‚Üí Student.StudentID (Foreign Key)</li>
<li>Enrollment.CourseID ‚Üí Course.CourseID (Foreign Key)</li>
</ul>

<hr>

<h3>How to Identify Transitive Dependencies</h3>

<p><strong>Follow these steps for every table:</strong></p>

<pre><code>STEP 1: List ALL Functional Dependencies
‚îú‚îÄ Write down every dependency in the table
‚îú‚îÄ Include both direct and potential indirect ones
‚îî‚îÄ Format: FieldA ‚Üí FieldB

STEP 2: Look for Dependency Chains
‚îú‚îÄ Find patterns: A ‚Üí B ‚Üí C
‚îú‚îÄ Ask: "Does the primary key determine B, and then B determines C?"
‚îî‚îÄ If YES ‚Üí you found a transitive dependency

STEP 3: Check Non-Key Dependencies
‚îú‚îÄ For each non-key attribute, ask: "Does it depend on another non-key attribute?"
‚îú‚îÄ Example: Does InstructorName depend on InstructorID (both non-key)?
‚îî‚îÄ If YES ‚Üí transitive dependency exists

STEP 4: Verify the Problem
‚îú‚îÄ Ask: "If I change the intermediate value, do I have to update multiple rows?"
‚îî‚îÄ If YES ‚Üí this transitive dependency is causing anomalies
</code></pre>

<p><strong>When You're Stuck:</strong></p>
<ul>
<li>üîç Can't find chains? Look for attributes that describe OTHER attributes (not the primary key)</li>
<li>üîç Not sure if it's transitive? Ask: "Does this field tell me about the key, or about another field?"</li>
<li>üîç Confused about what's wrong? Remember: Every non-key field should depend ONLY on the primary key</li>
</ul>

<hr>

<h3>Worked Example: Course Table Analysis</h3>

<p>Let's apply the 4-step process to our Course table (Primary Key = CourseID):</p>

<p><strong>STEP 1: List ALL Functional Dependencies</strong></p>

<pre><code>CourseID ‚Üí CourseName
CourseID ‚Üí Credits
CourseID ‚Üí InstructorID
CourseID ‚Üí InstructorName
CourseID ‚Üí InstructorOffice
CourseID ‚Üí InstructorPhone
InstructorID ‚Üí InstructorName
InstructorID ‚Üí InstructorOffice
InstructorID ‚Üí InstructorPhone
</code></pre>

<p><strong>STEP 2: Look for Dependency Chains</strong></p>

<pre><code>Chain 1: CourseID ‚Üí InstructorID ‚Üí InstructorName ‚úó FOUND ONE!
Chain 2: CourseID ‚Üí InstructorID ‚Üí InstructorOffice ‚úó FOUND ANOTHER!
Chain 3: CourseID ‚Üí InstructorID ‚Üí InstructorPhone ‚úó AND ANOTHER!
</code></pre>

<p><strong>STEP 3: Check Non-Key Dependencies</strong></p>

<pre><code>InstructorName (non-key) depends on InstructorID (non-key) ‚úó PROBLEM!
InstructorOffice (non-key) depends on InstructorID (non-key) ‚úó PROBLEM!
InstructorPhone (non-key) depends on InstructorID (non-key) ‚úó PROBLEM!

CourseName (non-key) depends on CourseID (key) ‚úì OK
Credits (non-key) depends on CourseID (key) ‚úì OK
</code></pre>

<p><strong>STEP 4: Verify the Problem</strong></p>

<p>If Dr. Johnson (I001) moves to Room 102:</p>
<ul>
<li>Must update CS101 row</li>
<li>Must update CS201 row</li>
<li>Two updates for one fact = UPDATE ANOMALY ‚úó</li>
</ul>

<p><strong>Conclusion:</strong> We have transitive dependencies that need fixing with 3NF!</p>

<p><strong>Original Dependencies:</strong></p>
<ul>
<li><code>CourseID ‚Üí CourseName</code> ‚úì (Direct dependency - OK)</li>
<li><code>CourseID ‚Üí Credits</code> ‚úì (Direct dependency - OK)</li>
<li><code>CourseID ‚Üí InstructorID</code> ‚úì (Direct dependency - OK)</li>
<li><code>CourseID ‚Üí InstructorName</code> ‚úó (Transitive through InstructorID)</li>
<li><code>CourseID ‚Üí InstructorOffice</code> ‚úó (Transitive through InstructorID)</li>
<li><code>CourseID ‚Üí InstructorPhone</code> ‚úó (Transitive through InstructorID)</li>
</ul>

<p><strong>Solution:</strong> Move transitively dependent attributes (InstructorName, InstructorOffice, InstructorPhone) to a separate INSTRUCTOR table.</p>

<hr>

<p>‚úã <strong>CHECKPOINT #1: Check Your Understanding</strong></p>

<p>Consider this table:</p>

<table>
<thead>
<tr>
<th>OrderID</th>
<th>ProductID</th>
<th>ProductName</th>
<th>CategoryID</th>
<th>CategoryName</th>
</tr>
</thead>
<tbody>
<tr>
<td>1001</td>
<td>P50</td>
<td>Laptop</td>
<td>C10</td>
<td>Electronics</td>
</tr>
<tr>
<td>1002</td>
<td>P51</td>
<td>Mouse</td>
<td>C10</td>
<td>Electronics</td>
</tr>
</tbody>
</table>

<p><strong>Use the 4-step process to analyze this table (Primary Key = OrderID):</strong></p>

<p><strong>STEP 1: List all functional dependencies</strong></p>

<pre><code>OrderID ‚Üí ProductID
OrderID ‚Üí ProductName
OrderID ‚Üí CategoryID
OrderID ‚Üí CategoryName
ProductID ‚Üí ProductName
ProductID ‚Üí CategoryID
CategoryID ‚Üí CategoryName
</code></pre>

<p><strong>STEP 2: Look for dependency chains</strong></p>

<pre><code>Chain 1: OrderID ‚Üí ProductID ‚Üí ProductName ‚úó Found!
Chain 2: OrderID ‚Üí ProductID ‚Üí CategoryID ‚úó Found!
Chain 3: OrderID ‚Üí CategoryID ‚Üí CategoryName ‚úó Found!
</code></pre>

<p><strong>STEP 3: Check non-key dependencies</strong></p>

<pre><code>ProductName (non-key) depends on ProductID (non-key) ‚úó
CategoryID (non-key) depends on ProductID (non-key) ‚úó
CategoryName (non-key) depends on CategoryID (non-key) ‚úó
</code></pre>

<p><strong>STEP 4: Verify the problem</strong></p>

<p>If "Electronics" category name changes to "Electronic Devices":</p>
<ul>
<li>Must update every order with CategoryID C10</li>
<li>Multiple updates = UPDATE ANOMALY ‚úó</li>
</ul>

<p><strong>Questions:</strong></p>
<ol>
<li>Is this table in 2NF? (Assume OrderID is the primary key)</li>
<li>Identify the transitive dependency chains</li>
<li>How many tables would you create for 3NF?</li>
</ol>

<p><strong>Answers:</strong></p>
<ol>
<li>Yes, it's in 2NF (single-field primary key, so no partial dependencies possible)</li>
<li>Three chains:
<ul>
<li><code>OrderID ‚Üí ProductID ‚Üí ProductName</code></li>
<li><code>OrderID ‚Üí ProductID ‚Üí CategoryID</code></li>
<li><code>OrderID ‚Üí CategoryID ‚Üí CategoryName</code></li>
</ul>
</li>
<li>Four tables: ORDER (OrderID, ProductID), PRODUCT (ProductID, ProductName, CategoryID), CATEGORY (CategoryID, CategoryName), and possibly ORDER_DETAIL if needed</li>
</ol>

<p><em>Take 3 minutes to work through this with a partner before checking the answers.</em></p>

<hr>

<h2>üß© In-Class Practice: Applying 3NF</h2>

<h3>How to Approach These Problems</h3>

<p><strong>Follow the same 4-step process:</strong></p>
<ol>
<li>List ALL functional dependencies</li>
<li>Look for dependency chains (A ‚Üí B ‚Üí C)</li>
<li>Check if non-key attributes depend on other non-key attributes</li>
<li>Decompose: Create separate tables to eliminate transitive dependencies</li>
</ol>

<hr>

<h3>Example 1: Employee Department System</h3>

<p><strong>Instructions</strong>: Work in pairs (8 minutes)</p>

<p><strong>Current Table:</strong></p>

<table>
<thead>
<tr>
<th>EmpID</th>
<th>EmpName</th>
<th>DeptID</th>
<th>DeptName</th>
<th>DeptLocation</th>
<th>Salary</th>
</tr>
</thead>
<tbody>
<tr>
<td>E01</td>
<td>Alice</td>
<td>D10</td>
<td>Sales</td>
<td>Building A</td>
<td>50000</td>
</tr>
<tr>
<td>E02</td>
<td>Bob</td>
<td>D10</td>
<td>Sales</td>
<td>Building A</td>
<td>55000</td>
</tr>
<tr>
<td>E03</td>
<td>Carol</td>
<td>D20</td>
<td>IT</td>
<td>Building B</td>
<td>60000</td>
</tr>
</tbody>
</table>

<p>Primary Key: EmpID</p>

<p><strong>Tasks:</strong></p>
<ol>
<li>List all functional dependencies</li>
<li>Identify transitive dependency chains</li>
<li>Decompose into 3NF tables</li>
<li>Show primary/foreign keys</li>
</ol>

<p><strong>Guided Help:</strong></p>
<ul>
<li><strong>Finding chains:</strong> Does DeptName depend on EmpID directly, or through DeptID?</li>
<li><strong>Pattern:</strong> DeptName and DeptLocation describe the DEPARTMENT, not the EMPLOYEE</li>
<li><strong>Expected tables:</strong> 2 tables (EMPLOYEE, DEPARTMENT)</li>
</ul>

<hr>

<h3>Example 2: Product Supplier System</h3>

<p><strong>Instructions</strong>: Work in pairs (8 minutes)</p>

<p><strong>Current Table:</strong></p>

<table>
<thead>
<tr>
<th>ProductID</th>
<th>ProductName</th>
<th>SupplierID</th>
<th>SupplierName</th>
<th>SupplierCity</th>
<th>Price</th>
</tr>
</thead>
<tbody>
<tr>
<td>P100</td>
<td>Widget</td>
<td>S01</td>
<td>Acme Corp</td>
<td>New York</td>
<td>10.50</td>
</tr>
<tr>
<td>P101</td>
<td>Gadget</td>
<td>S01</td>
<td>Acme Corp</td>
<td>New York</td>
<td>15.00</td>
</tr>
<tr>
<td>P102</td>
<td>Doohickey</td>
<td>S02</td>
<td>Tech Supply</td>
<td>Boston</td>
<td>8.75</td>
</tr>
</tbody>
</table>

<p>Primary Key: ProductID</p>

<p><strong>Tasks:</strong></p>
<ol>
<li>Apply the 4-step process</li>
<li>Identify ALL transitive dependencies</li>
<li>Create 3NF decomposition</li>
<li>Explain what anomalies are prevented</li>
</ol>

<p><strong>Guided Help:</strong></p>
<ul>
<li><strong>Step 1:</strong> Write down dependencies - don't forget SupplierID ‚Üí SupplierName and SupplierID ‚Üí SupplierCity</li>
<li><strong>Step 2:</strong> Look for chains through SupplierID</li>
<li><strong>Step 3:</strong> SupplierName and SupplierCity tell you about the SUPPLIER, not the PRODUCT</li>
<li><strong>Expected tables:</strong> 2 tables (PRODUCT, SUPPLIER)</li>
</ul>

<hr>

<h3>Practice Review &amp; Discussion (5 minutes)</h3>

<p><strong>Example 1 Solution:</strong></p>

<p><strong>EMPLOYEE Table:</strong></p>

<table>
<thead>
<tr>
<th>EmpID</th>
<th>EmpName</th>
<th>DeptID</th>
<th>Salary</th>
</tr>
</thead>
<tbody>
<tr>
<td>E01</td>
<td>Alice</td>
<td>D10</td>
<td>50000</td>
</tr>
<tr>
<td>E02</td>
<td>Bob</td>
<td>D10</td>
<td>55000</td>
</tr>
<tr>
<td>E03</td>
<td>Carol</td>
<td>D20</td>
<td>60000</td>
</tr>
</tbody>
</table>

<p><strong>DEPARTMENT Table:</strong></p>

<table>
<thead>
<tr>
<th>DeptID</th>
<th>DeptName</th>
<th>DeptLocation</th>
</tr>
</thead>
<tbody>
<tr>
<td>D10</td>
<td>Sales</td>
<td>Building A</td>
</tr>
<tr>
<td>D20</td>
<td>IT</td>
<td>Building B</td>
</tr>
</tbody>
</table>

<p><strong>Transitive dependencies eliminated:</strong></p>
<ul>
<li>EmpID ‚Üí DeptID ‚Üí DeptName ‚úì Fixed</li>
<li>EmpID ‚Üí DeptID ‚Üí DeptLocation ‚úì Fixed</li>
</ul>

<p><strong>Anomalies prevented:</strong></p>
<ul>
<li>Update: Change "Sales" name in ONE place (not two)</li>
<li>Insert: Can add departments without employees</li>
<li>Delete: Removing employees doesn't lose department info</li>
</ul>

<hr>

<p><strong>Example 2 Solution:</strong></p>

<p><strong>PRODUCT Table:</strong></p>

<table>
<thead>
<tr>
<th>ProductID</th>
<th>ProductName</th>
<th>SupplierID</th>
<th>Price</th>
</tr>
</thead>
<tbody>
<tr>
<td>P100</td>
<td>Widget</td>
<td>S01</td>
<td>10.50</td>
</tr>
<tr>
<td>P101</td>
<td>Gadget</td>
<td>S01</td>
<td>15.00</td>
</tr>
<tr>
<td>P102</td>
<td>Doohickey</td>
<td>S02</td>
<td>8.75</td>
</tr>
</tbody>
</table>

<p><strong>SUPPLIER Table:</strong></p>

<table>
<thead>
<tr>
<th>SupplierID</th>
<th>SupplierName</th>
<th>SupplierCity</th>
</tr>
</thead>
<tbody>
<tr>
<td>S01</td>
<td>Acme Corp</td>
<td>New York</td>
</tr>
<tr>
<td>S02</td>
<td>Tech Supply</td>
<td>Boston</td>
</tr>
</tbody>
</table>

<p><strong>Key insight:</strong> Notice Acme Corp appears only ONCE now (was in 2 rows before)</p>

<hr>

<h2>Looking Ahead: Beyond 3NF</h2>

<h3>You've Mastered the Industry Standard!</h3>

<p><strong>Congratulations!</strong> With 3NF, you now know the normalization level used in most professional databases.</p>

<p><strong>What about BCNF, 4NF, 5NF?</strong></p>

<p>These advanced normal forms handle rare edge cases:</p>
<ul>
<li><strong>BCNF (Boyce-Codd NF)</strong>: Stricter than 3NF - handles special cases with overlapping candidate keys</li>
<li><strong>4NF</strong>: Eliminates multi-valued dependencies</li>
<li><strong>5NF</strong>: Handles complex join dependencies</li>
</ul>

<p><strong>Good news:</strong> We'll explore these in detail in <strong>Class 3</strong>!</p>

<p><strong>For now:</strong> Focus on mastering 3NF - it's what you'll use 95% of the time in real applications.</p>

<hr>

<p>‚úã <strong>CHECKPOINT #2: Check Your Understanding</strong></p>

<p><strong>Question:</strong> Why is 3NF considered the "industry standard"?</p>

<p><strong>Answer:</strong></p>
<ul>
<li>‚úÖ Eliminates most common anomalies (update, insert, delete)</li>
<li>‚úÖ Balances data integrity with query performance</li>
<li>‚úÖ Easier to understand and maintain than higher forms</li>
<li>‚úÖ Sufficient for the vast majority of real-world applications</li>
<li>‚úÖ Higher normal forms (BCNF, 4NF, 5NF) are rarely needed</li>
</ul>

<p><strong>Takeaway:</strong> If you can normalize to 3NF confidently, you have a valuable professional skill!</p>

<hr>

<h2>Practical Considerations</h2>

<h3>When to Stop Normalizing:</h3>

<h4>3NF is Usually Enough:</h4>

<ul>
<li>‚úÖ Eliminates most common anomalies</li>
<li>‚úÖ Balances data integrity with query performance</li>
<li>‚úÖ Easier to understand and maintain</li>
<li>‚úÖ Industry standard for most applications</li>
</ul>

<h4>When to Consider Higher Forms (BCNF, 4NF):</h4>

<ul>
<li>You have rare edge cases that 3NF doesn't handle (we'll learn to recognize these in Class 3)</li>
<li>3NF still shows anomalies in your specific domain</li>
<li>Data integrity is more important than query complexity</li>
<li>The specific constraints of your domain require it</li>
</ul>

<hr>

<h3>Real-World Trade-offs:</h3>

<p><strong>Benefits of Higher Normalization:</strong></p>

<ul>
<li>‚úÖ Better data integrity</li>
<li>‚úÖ Reduced redundancy</li>
<li>‚úÖ Easier to maintain consistency</li>
<li>‚úÖ Prevents update/insert/delete anomalies</li>
</ul>

<p><strong>Costs of Higher Normalization:</strong></p>

<ul>
<li>‚ùå More complex queries (more JOINs)</li>
<li>‚ùå Potentially slower performance</li>
<li>‚ùå More complex application logic</li>
<li>‚ùå Harder for non-technical users to understand</li>
</ul>

<hr>

<h3>Example Query Complexity:</h3>

<p><strong>Task:</strong> Finding all students and their instructor names</p>

<p><strong>Unnormalized (1 table):</strong></p>

<pre><code>SELECT StudentName, InstructorName
FROM BigTable;
</code></pre>

<p><strong>3NF (4 tables):</strong></p>

<pre><code>SELECT s.StudentName, i.InstructorName
FROM Student s
JOIN Enrollment e ON s.StudentID = e.StudentID
JOIN Course c ON e.CourseID = c.CourseID
JOIN Instructor i ON c.InstructorID = i.InstructorID;
</code></pre>

<p><strong>The Trade-off:</strong> More JOINs but much better data integrity.</p>

<p>üí° <strong>Key Insight:</strong> The unnormalized query is simpler, but if Dr. Johnson's name is misspelled in 50 different rows, you have 50 problems. In 3NF, you fix it once.</p>

<hr>

<h2>Class 2 Assignment: Advanced Normalization</h2>

<h3>Objective</h3>

<p>Apply 3NF and BCNF concepts to eliminate transitive dependencies and complex key relationships.</p>

<h3>Instructions</h3>

<p><strong>Part 1: Review and Extend (20 points)</strong></p>

<p><strong>Step-by-step instructions:</strong></p>
<ol>
<li>Open your <code>LastName_FirstName_Normalization1.xlsx</code> from Class 1</li>
<li>Download <code>Class2_ExtendedData.xlsx</code> from Canvas</li>
<li>Copy the instructor and department data into a new tab called "Extended Data"</li>
<li>Use the 4-step process (from lines 223-242) to identify transitive dependencies</li>
<li>Create a new tab called "Transitive Dependencies Found"</li>
<li>List all transitive dependency chains in this format:
<ul>
<li><code>Table: COURSE</code></li>
<li><code>Chain: CourseID ‚Üí InstructorID ‚Üí InstructorName</code></li>
</ul>
</li>
</ol>

<p><strong>Part 2: 3NF Normalization (60 points)</strong> ‚Üê <em>Main focus of assignment</em></p>

<p><strong>Step-by-step instructions:</strong></p>
<ol>
<li>For each transitive dependency you found, create a new table</li>
<li>Follow the pattern from in-class examples (Employee/Department, Product/Supplier)</li>
<li>In a new tab called "3NF Tables", show:
<ul>
<li>All tables in 3NF format</li>
<li>Primary keys marked clearly (highlight or [PK] notation)</li>
<li>Foreign keys marked clearly (different color or [FK] notation)</li>
</ul>
</li>
<li>In a new tab called "3NF Analysis", document:
<ul>
<li>What transitive dependencies were eliminated</li>
<li>What anomalies are now prevented (update, insert, delete)</li>
</ul>
</li>
</ol>

<p><strong>Grading criteria:</strong></p>
<ul>
<li>All transitive dependencies identified and eliminated (40 pts)</li>
<li>Correct primary/foreign key relationships (15 pts)</li>
<li>Clear documentation of improvements (5 pts)</li>
</ul>

<p><strong>Part 3: BCNF Analysis (EXTRA CREDIT - 10 points)</strong></p>

<p><strong>This part is optional! 3NF is sufficient for full credit.</strong></p>

<p>If you want extra credit:</p>
<ol>
<li>For EACH of your 3NF tables, check: "Is every determinant a superkey?"</li>
<li>If you find violations, explain whether to apply BCNF or stop at 3NF</li>
<li>Explain your reasoning using the decision rules from lines 602-617</li>
</ol>

<p><strong>Most students will not need BCNF - that's normal and correct!</strong></p>

<p><strong>Part 4: Reflection on Trade-offs (10 points)</strong></p>

<p>Answer these questions in a new tab called "Reflection":</p>
<ol>
<li>How many tables did you start with? How many do you have now in 3NF?</li>
<li>If you had to find all students and their instructors:
<ul>
<li>How many tables would you need to connect (JOIN)?</li>
<li>Is this more complex than the original design?</li>
</ul>
</li>
<li>In your own words: Why is the extra complexity worth it?</li>
<li>Give ONE example from your design where 3NF prevents an anomaly</li>
</ol>

<h3>Submission Format</h3>

<p>Excel file with tabs:</p>

<ul>
<li><strong>Tab 1:</strong> Extended Data (from Class2_ExtendedData.xlsx)</li>
<li><strong>Tab 2:</strong> Transitive Dependencies Found (list of chains)</li>
<li><strong>Tab 3:</strong> 3NF Tables (your decomposed tables)</li>
<li><strong>Tab 4:</strong> 3NF Analysis (what you fixed and why)</li>
<li><strong>Tab 5:</strong> Reflection (trade-off questions)</li>
<li><strong>Tab 6 (Optional):</strong> BCNF Analysis (extra credit)</li>
</ul>

<p><strong>File name:</strong> <code>LastName_FirstName_Normalization2.xlsx</code><br>
<strong>Due:</strong> Next class</p>

<hr>

<h3>Assessment Rubric</h3>

<table>
<thead>
<tr>
<th>Criteria</th>
<th>Points</th>
<th>Excellent (90-100%)</th>
<th>Good (80-89%)</th>
<th>Needs Work (&lt;80%)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Transitive Dependency ID</td>
<td>20</td>
<td>Found all 5+ transitive dependencies</td>
<td>Found 3-4 dependencies</td>
<td>Found fewer than 3</td>
</tr>
<tr>
<td>3NF Decomposition</td>
<td>40</td>
<td>Perfect table structure, all keys correct</td>
<td>Minor issues with 1-2 relationships</td>
<td>Incorrect structure or missing tables</td>
</tr>
<tr>
<td>Primary/Foreign Key Notation</td>
<td>15</td>
<td>All keys clearly marked and correct</td>
<td>Most keys correct, minor notation issues</td>
<td>Many keys missing or incorrect</td>
</tr>
<tr>
<td>Documentation &amp; Analysis</td>
<td>15</td>
<td>Clear explanation of all improvements</td>
<td>Good explanation with minor gaps</td>
<td>Poor or missing analysis</td>
</tr>
<tr>
<td>Reflection on Trade-offs</td>
<td>10</td>
<td>Thoughtful answers showing understanding</td>
<td>Adequate answers with minor issues</td>
<td>Superficial or missing responses</td>
</tr>
<tr>
<td><strong>EXTRA CREDIT: BCNF</strong></td>
<td>+10</td>
<td>Thorough BCNF analysis and decision</td>
<td>Good attempt with minor gaps</td>
<td>Incomplete analysis</td>
</tr>
</tbody>
</table>

<p><strong>Note:</strong> BCNF is optional. You can earn 100% without attempting it.</p>

<hr>

<h3>Extended Dataset</h3>

<p><code>Class2_ExtendedData.xlsx</code> includes:</p>

<ul>
<li>Original student/course data from Class 1</li>
<li>Instructor information with departments</li>
<li>Department information with locations</li>
<li>Additional complexity for transitive dependencies</li>
</ul>

<hr>

<h3>Tips for Success</h3>

<ul>
<li>üìä <strong>Draw dependency diagrams</strong> - Visual representations help identify chains</li>
<li>üîç <strong>Check every non-key attribute</strong> - Does it depend directly on the primary key?</li>
<li>üí° <strong>Look for "information about information"</strong> - Often signals transitive dependencies</li>
<li>‚úÖ <strong>Test your design</strong> - Can you add/update/delete without anomalies?</li>
</ul>

<hr>

<h2>Next Class Preview</h2>

<p>Class 3 will cover advanced normal forms (4NF, 5NF) and modern database considerations including NoSQL, performance optimization, and when to denormalize.</p>

<hr>

<h2>‚úã EXIT TICKET (Required - Turn in Before Leaving)</h2>

<p><strong>Answer these 3 questions on an index card or paper:</strong></p>

<ol>
<li><strong>Confidence Check:</strong> On a scale of 1-5, how confident are you identifying transitive dependencies?
<ul>
<li>1 = Very confused</li>
<li>3 = Getting it but need more practice</li>
<li>5 = Very confident</li>
</ul>
</li>
<li><strong>Quick Application:</strong> In this table with Primary Key = StudentID:
<pre><code>StudentID ‚Üí AdvisorID ‚Üí AdvisorOffice
</code></pre>
Is AdvisorOffice directly or transitively dependent on StudentID? ____________________
</li>
<li><strong>Reflection:</strong> What's ONE thing that's still confusing about 3NF or normalization in general? (Or write "Nothing - I'm good!" if you feel confident)</li>
</ol>

<p><em>Your instructor will review these before next class to address common confusion points.</em></p>

<hr>

<h2>Key Takeaways</h2>

<ul>
<li><strong>3NF eliminates transitive dependencies</strong> - no non-key attribute should depend on another non-key attribute</li>
<li><strong>BCNF is stricter than 3NF</strong> - every determinant must be a superkey</li>
<li><strong>Most real-world databases stop at 3NF</strong> for practical reasons</li>
<li><strong>Higher normalization trades query complexity for data integrity</strong></li>
<li><strong>Always consider your specific use case</strong> when choosing normal form level</li>
</ul>

<hr>

<h2>Quick Reference: 3NF vs BCNF</h2>

<h3>3NF Checklist:</h3>

<ul>
<li>‚úì Already in 2NF</li>
<li>‚úì No transitive dependencies</li>
<li>‚úì All non-key attributes directly depend on primary key</li>
</ul>

<h3>BCNF Checklist:</h3>

<ul>
<li>‚úì Already in 3NF</li>
<li>‚úì Every functional dependency has a superkey as determinant</li>
<li>‚úì No anomalies from overlapping candidate keys</li>
</ul>

<hr>

<h2>Common 3NF Violations to Watch For:</h2>

<p>Look for these patterns - they often indicate transitive dependencies:</p>

<ul>
<li><code>Employee ‚Üí Department ‚Üí DepartmentLocation</code></li>
<li><code>Order ‚Üí Customer ‚Üí CustomerCreditRating</code></li>
<li><code>Product ‚Üí Category ‚Üí CategoryDescription</code></li>
<li><code>Course ‚Üí Instructor ‚Üí InstructorOffice</code></li>
</ul>

<p><strong>Pattern to recognize:</strong> "Information about the information"</p>
<ul>
<li>If you have InstructorID, and then InstructorOffice tells you about the instructor (not the course), that's transitive!</li>
</ul>

<hr>

<p><strong>Remember:</strong> The goal is to eliminate anomalies while maintaining practical usability!</p>

</body>
</html>
