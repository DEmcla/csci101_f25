<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Module 2 Study Guide: Database Design & Normalization</title>
    <style>
        body {
            font-family: Georgia, serif;
            line-height: 1.8;
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
            background-color: #fafafa;
            color: #333;
        }
        h1 {
            color: #1a1a1a;
            border-bottom: 3px solid #2c5282;
            padding-bottom: 10px;
        }
        h2 {
            color: #2c5282;
            margin-top: 35px;
            border-left: 5px solid #2c5282;
            padding-left: 15px;
        }
        h3 {
            color: #2d3748;
            margin-top: 25px;
        }
        .concept {
            background-color: #fff;
            border: 1px solid #e2e8f0;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .definition {
            background-color: #edf2f7;
            border-left: 4px solid #4299e1;
            padding: 15px;
            margin: 15px 0;
        }
        .example {
            background-color: #f7fafc;
            border: 1px solid #cbd5e0;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
        }
        .insight {
            background-color: #fffaf0;
            border-left: 4px solid #ed8936;
            padding: 15px;
            margin: 15px 0;
            font-style: italic;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: #fff;
        }
        th {
            background-color: #2c5282;
            color: white;
            padding: 12px;
            text-align: left;
        }
        td {
            border: 1px solid #e2e8f0;
            padding: 12px;
        }
        code {
            background-color: #edf2f7;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        pre {
            background-color: #1a202c;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            line-height: 1.5;
        }
        .practice {
            background-color: #faf5ff;
            border: 2px solid #9f7aea;
            padding: 20px;
            margin: 25px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>

<h1>Module 2 Study Guide: Database Design & Normalization</h1>

<h2>Part 1: Database Tables - The Foundation</h2>

<div class="concept">
    <h3>What is a Database Table?</h3>

    <div class="definition">
        <p><strong>Table (Relation):</strong> A structured collection of data organized in rows and columns, where each row represents a single record and each column represents an attribute of that record.</p>
    </div>

    <h4>Core Components:</h4>

    <p><strong>Attributes (Columns):</strong> The properties or characteristics we track about an entity. Each attribute has a domain (the set of allowable values).</p>

    <p><strong>Tuples (Rows):</strong> Individual records containing specific values for each attribute.</p>

    <p><strong>Schema:</strong> The structure of a table - its name, attributes, data types, and constraints.</p>

    <div class="example">
STUDENT Table Schema:
StudentID (integer, primary key)
FirstName (varchar(50), not null)
LastName (varchar(50), not null)
Email (varchar(100), unique)
DateOfBirth (date)
    </div>
</div>

<div class="concept">
    <h3>Attributes: Properties of Data</h3>

    <p><strong>Simple vs. Composite Attributes:</strong></p>
    <ul>
        <li><strong>Simple:</strong> Cannot be divided further (e.g., StudentID, Email)</li>
        <li><strong>Composite:</strong> Can be broken into sub-parts (e.g., FullName ‚Üí FirstName + LastName)</li>
    </ul>

    <p><strong>Single-valued vs. Multi-valued:</strong></p>
    <ul>
        <li><strong>Single-valued:</strong> One value per record (e.g., DateOfBirth)</li>
        <li><strong>Multi-valued:</strong> Multiple values possible (e.g., PhoneNumbers) - these require special handling</li>
    </ul>

    <p><strong>Stored vs. Derived Attributes:</strong></p>
    <ul>
        <li><strong>Stored:</strong> Explicitly stored in the database (e.g., DateOfBirth)</li>
        <li><strong>Derived:</strong> Calculated from other attributes (e.g., Age calculated from DateOfBirth)</li>
    </ul>
</div>

<div class="concept">
    <h3>Entities and Entity Sets</h3>

    <div class="definition">
        <p><strong>Entity:</strong> A distinguishable object or concept in the real world that we want to store information about (e.g., a specific student, a particular course).</p>

        <p><strong>Entity Set:</strong> A collection of similar entities (e.g., all students, all courses).</p>
    </div>

    <p><strong>Strong vs. Weak Entities:</strong></p>
    <ul>
        <li><strong>Strong Entity:</strong> Can exist independently, has its own primary key (e.g., STUDENT, COURSE)</li>
        <li><strong>Weak Entity:</strong> Depends on another entity for identification (e.g., ROOM depends on BUILDING)</li>
    </ul>
</div>

<div class="concept">
    <h3>Constraints: Rules for Data Integrity</h3>

    <p><strong>Domain Constraints:</strong> Restrict the values an attribute can hold.</p>
    <div class="example">
Age integer CHECK (Age >= 0 AND Age <= 120)
Grade char(2) CHECK (Grade IN ('A', 'B', 'C', 'D', 'F'))
    </div>

    <p><strong>Key Constraints:</strong> Ensure unique identification of records.</p>

    <p><strong>Entity Integrity:</strong> Primary key cannot be NULL.</p>

    <p><strong>Referential Integrity:</strong> Foreign keys must reference existing primary keys.</p>

    <p><strong>Semantic Constraints:</strong> Business rules (e.g., "A student cannot enroll in more than 20 credits per semester").</p>
</div>

<hr>

<h2>Part 2: Keys - Unique Identification</h2>

<div class="concept">
    <h3>Superkeys</h3>

    <div class="definition">
        <p><strong>Superkey:</strong> Any set of one or more attributes that uniquely identifies a tuple (row) in a table. A superkey may contain extra attributes beyond what's minimally necessary.</p>
    </div>

    <div class="example">
In STUDENT table:
- {StudentID} is a superkey
- {StudentID, Email} is a superkey (but includes extra attribute)
- {StudentID, FirstName, LastName} is a superkey (but includes extra attributes)
- {Email} is a superkey (assuming emails are unique)
    </div>

    <div class="insight">
        <strong>Key Insight:</strong> Every table has multiple superkeys. The challenge is finding the minimal one.
    </div>
</div>

<div class="concept">
    <h3>Candidate Keys</h3>

    <div class="definition">
        <p><strong>Candidate Key:</strong> A minimal superkey - a superkey with no unnecessary attributes. If you remove any attribute from a candidate key, it will no longer uniquely identify tuples.</p>
    </div>

    <div class="example">
In STUDENT table:
- {StudentID} is a candidate key (minimal)
- {Email} is a candidate key (minimal)
- {StudentID, Email} is NOT a candidate key (not minimal - can remove either one)
    </div>

    <p><strong>Properties of Candidate Keys:</strong></p>
    <ul>
        <li>Uniqueness: No two tuples can have the same values for all attributes in the candidate key</li>
        <li>Irreducibility: Cannot remove any attribute and maintain uniqueness</li>
        <li>A table may have multiple candidate keys</li>
    </ul>
</div>

<div class="concept">
    <h3>Primary Keys</h3>

    <div class="definition">
        <p><strong>Primary Key (PK):</strong> The candidate key chosen by the database designer to be the main identifier for a table. There can be only one primary key per table.</p>
    </div>

    <p><strong>Types of Primary Keys:</strong></p>

    <p><strong>1. Simple Primary Key:</strong> Single attribute</p>
    <div class="example">
STUDENT(StudentID, Name, Email)
PK: StudentID
    </div>

    <p><strong>2. Composite Primary Key:</strong> Multiple attributes combined</p>
    <div class="example">
ENROLLMENT(StudentID, CourseID, Semester, Grade)
PK: {StudentID, CourseID, Semester}
    </div>

    <p><strong>3. Surrogate Key:</strong> Artificial identifier created for use as primary key</p>
    <div class="example">
PERSON(PersonID, SSN, FirstName, LastName, DateOfBirth)
PK: PersonID (surrogate)
Natural candidate key: SSN
    </div>

    <div class="insight">
        <strong>Design Principle:</strong> Choose primary keys that are stable (won't change), simple (preferably single attribute), and meaningless (not based on real-world data that might change).
    </div>
</div>

<div class="concept">
    <h3>Foreign Keys</h3>

    <div class="definition">
        <p><strong>Foreign Key (FK):</strong> An attribute (or set of attributes) in one table that references the primary key of another table, establishing a relationship between the two tables.</p>
    </div>

    <div class="example">
DEPARTMENT(DeptID, DeptName, Building)
PK: DeptID

COURSE(CourseID, CourseName, Credits, DeptID)
PK: CourseID
FK: DeptID REFERENCES DEPARTMENT(DeptID)
    </div>

    <p><strong>Referential Integrity Rules:</strong></p>
    <ul>
        <li>A foreign key value must match an existing primary key value in the referenced table, OR</li>
        <li>The foreign key value can be NULL (if the relationship is optional)</li>
    </ul>

    <p><strong>Actions on Referenced Data:</strong></p>
    <ul>
        <li><strong>ON DELETE CASCADE:</strong> Delete referencing rows when referenced row is deleted</li>
        <li><strong>ON DELETE SET NULL:</strong> Set foreign key to NULL when referenced row is deleted</li>
        <li><strong>ON DELETE RESTRICT:</strong> Prevent deletion if referencing rows exist</li>
        <li><strong>ON UPDATE CASCADE:</strong> Update foreign key when primary key changes</li>
    </ul>
</div>

<hr>

<h2>Part 3: Relationships Between Tables</h2>

<div class="concept">
    <h3>Cardinality: Understanding Relationship Types</h3>

    <div class="definition">
        <p><strong>Cardinality:</strong> Describes how many instances of one entity can be associated with instances of another entity.</p>
    </div>
</div>

<div class="concept">
    <h3>One-to-One (1:1) Relationships</h3>

    <p><strong>Definition:</strong> Each instance of Entity A is associated with at most one instance of Entity B, and vice versa.</p>

    <p><strong>Examples:</strong></p>
    <ul>
        <li>Person ‚Üî Passport (one person has one passport, one passport belongs to one person)</li>
        <li>Employee ‚Üî Parking Space (one employee assigned one parking space)</li>
    </ul>

    <p><strong>Implementation Options:</strong></p>

    <p><strong>Option 1:</strong> Foreign key in either table</p>
    <div class="example">
PERSON(PersonID, Name, PassportID)
PASSPORT(PassportID, Number, IssueDate, ExpiryDate)
    </div>

    <p><strong>Option 2:</strong> Merge into single table (if relationship is mandatory)</p>
    <div class="example">
PERSON(PersonID, Name, PassportNumber, PassportIssueDate, PassportExpiryDate)
    </div>
</div>

<div class="concept">
    <h3>One-to-Many (1:M) Relationships</h3>

    <p><strong>Definition:</strong> Each instance of Entity A can be associated with multiple instances of Entity B, but each instance of Entity B is associated with at most one instance of Entity A.</p>

    <p><strong>Examples:</strong></p>
    <ul>
        <li>Department ‚Üí Employees (one department has many employees)</li>
        <li>Customer ‚Üí Orders (one customer places many orders)</li>
        <li>Author ‚Üí Books (one author writes many books, if we ignore co-authorship)</li>
    </ul>

    <p><strong>Implementation:</strong> Place foreign key on the "many" side</p>

    <div class="example">
DEPARTMENT(DeptID, DeptName, Location)
PK: DeptID

EMPLOYEE(EmpID, FirstName, LastName, DeptID)
PK: EmpID
FK: DeptID REFERENCES DEPARTMENT(DeptID)
    </div>

    <div class="insight">
        <strong>Why this works:</strong> Each employee row stores its single department, allowing multiple employees to reference the same department.
    </div>
</div>

<div class="concept">
    <h3>Many-to-Many (M:N) Relationships</h3>

    <p><strong>Definition:</strong> Each instance of Entity A can be associated with multiple instances of Entity B, and each instance of Entity B can be associated with multiple instances of Entity A.</p>

    <p><strong>Examples:</strong></p>
    <ul>
        <li>Students ‚Üî Courses (students take multiple courses, courses have multiple students)</li>
        <li>Authors ‚Üî Books (authors write multiple books, books can have multiple authors)</li>
        <li>Actors ‚Üî Movies (actors appear in multiple movies, movies have multiple actors)</li>
    </ul>

    <p><strong>Implementation:</strong> Requires a bridge table (also called junction table, associative table, or linking table)</p>

    <div class="example">
STUDENT(StudentID, Name, Major)
PK: StudentID

COURSE(CourseID, CourseName, Credits)
PK: CourseID

ENROLLMENT(StudentID, CourseID, Semester, Grade)
PK: {StudentID, CourseID, Semester}
FK: StudentID REFERENCES STUDENT(StudentID)
FK: CourseID REFERENCES COURSE(CourseID)
    </div>

    <p><strong>Bridge Table Characteristics:</strong></p>
    <ul>
        <li>Primary key is typically a composite of the foreign keys</li>
        <li>Can include additional attributes specific to the relationship (Grade, Semester)</li>
        <li>Decomposes M:N into two 1:M relationships</li>
    </ul>
</div>

<div class="concept">
    <h3>Recursive Relationships</h3>

    <div class="definition">
        <p><strong>Recursive Relationship:</strong> A relationship where an entity is associated with itself. Also called self-referencing or unary relationships.</p>
    </div>

    <p><strong>Examples:</strong></p>

    <p><strong>1:M Recursive:</strong> Employee manages other employees</p>
    <div class="example">
EMPLOYEE(EmpID, Name, Salary, ManagerID)
PK: EmpID
FK: ManagerID REFERENCES EMPLOYEE(EmpID)

Example data:
EmpID | Name       | ManagerID
101   | Alice (CEO)| NULL
102   | Bob        | 101
103   | Carol      | 101
104   | Dave       | 102
    </div>

    <p><strong>M:N Recursive:</strong> Course prerequisites</p>
    <div class="example">
COURSE(CourseID, CourseName, Credits)
PK: CourseID

PREREQUISITE(CourseID, PrereqCourseID)
PK: {CourseID, PrereqCourseID}
FK: CourseID REFERENCES COURSE(CourseID)
FK: PrereqCourseID REFERENCES COURSE(CourseID)

Example data:
CourseID | PrereqCourseID
CS201    | CS101
CS301    | CS201
CS301    | CS220
    </div>
</div>

<hr>

<h2>Part 3.5: Entity-Relationship Diagrams (ERD) - Visual Modeling</h2>

<div class="concept">
    <h3>What is an Entity-Relationship Diagram?</h3>

    <div class="definition">
        <p><strong>Entity-Relationship Diagram (ERD):</strong> A visual representation of the entities in a database, their attributes, and the relationships between entities. ERDs are a design tool used before creating actual database tables.</p>
    </div>

    <p><strong>Purpose of ERDs:</strong></p>
    <ul>
        <li>Communicate database design to stakeholders</li>
        <li>Plan database structure before implementation</li>
        <li>Document existing database systems</li>
        <li>Identify entities, relationships, and constraints</li>
        <li>Serve as blueprint for creating tables</li>
    </ul>
</div>

<div class="concept">
    <h3>ERD Notation Conventions</h3>

    <p><strong>Naming Conventions:</strong></p>

    <table>
        <tr>
            <th>Element</th>
            <th>Case Convention</th>
            <th>Naming Style</th>
            <th>Example</th>
        </tr>
        <tr>
            <td><strong>Entity Names</strong></td>
            <td>UPPERCASE</td>
            <td>Singular nouns</td>
            <td>STUDENT, COURSE, DEPARTMENT</td>
        </tr>
        <tr>
            <td><strong>Attribute Names</strong></td>
            <td>lowercase</td>
            <td>Descriptive nouns</td>
            <td>studentID, firstName, email</td>
        </tr>
        <tr>
            <td><strong>Relationship Names</strong></td>
            <td>lowercase</td>
            <td>Verbs or verb phrases</td>
            <td>enrolls in, teaches, manages</td>
        </tr>
    </table>

    <p><strong>Attribute Formatting:</strong></p>
    <ul>
        <li><strong><u>Primary Key</u>:</strong> Bold AND underlined (e.g., <strong><u>studentID</u></strong>)</li>
        <li><strong>Required Attribute:</strong> Bold (e.g., <strong>lastName</strong>)</li>
        <li><u>Unique Attribute:</u> Underlined (e.g., <u>email</u>)</li>
        <li>Optional Attribute: Plain text (e.g., middleName)</li>
    </ul>

    <div class="example">
STUDENT Entity:
  <strong><u>studentID</u></strong>        (Primary key: bold + underlined)
  <strong>firstName</strong>         (Required: bold)
  <strong>lastName</strong>          (Required: bold)
  <u>email</u>              (Unique: underlined)
  phoneNumber        (Optional: plain)
  middleName         (Optional: plain)
    </div>
</div>

<div class="concept">
    <h3>ERD Symbols and Components</h3>

    <p><strong>Basic Shapes:</strong></p>

    <table>
        <tr>
            <th>Symbol</th>
            <th>Represents</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>Rectangle</strong></td>
            <td>Strong Entity</td>
            <td>An entity that can exist independently (STUDENT, COURSE)</td>
        </tr>
        <tr>
            <td><strong>Double Rectangle</strong></td>
            <td>Weak Entity</td>
            <td>An entity that depends on another entity for identification (ROOM depends on BUILDING)</td>
        </tr>
        <tr>
            <td><strong>Oval/Ellipse</strong></td>
            <td>Attribute</td>
            <td>Properties or characteristics of an entity (name, age)</td>
        </tr>
        <tr>
            <td><strong>Diamond</strong></td>
            <td>Relationship</td>
            <td>Association between entities (enrolls in, teaches)</td>
        </tr>
        <tr>
            <td><strong>Double Diamond</strong></td>
            <td>Identifying Relationship</td>
            <td>Relationship that provides identity to a weak entity</td>
        </tr>
        <tr>
            <td><strong>Line</strong></td>
            <td>Link</td>
            <td>Connects entities to relationships and attributes to entities</td>
        </tr>
    </table>

    <p><strong>Special Attribute Symbols:</strong></p>
    <ul>
        <li><strong>Underlined oval:</strong> Primary key attribute</li>
        <li><strong>Dashed underline oval:</strong> Partial key (discriminator) - part of weak entity's key</li>
        <li><strong>Dashed oval:</strong> Derived attribute (calculated, not stored)</li>
        <li><strong>Double oval:</strong> Multi-valued attribute (can have multiple values)</li>
        <li><strong>Composite oval:</strong> Attribute made of sub-attributes (can be expanded)</li>
    </ul>
</div>

<div class="concept">
    <h3>Strong Entities vs. Weak Entities</h3>

    <div class="definition">
        <p><strong>Strong Entity:</strong> An entity that has its own primary key and can exist independently. Represented by a single rectangle.</p>

        <p><strong>Weak Entity:</strong> An entity that cannot be uniquely identified by its own attributes alone - it depends on a related strong entity for identification. Represented by a double rectangle.</p>
    </div>

    <p><strong>Characteristics of Weak Entities:</strong></p>
    <ul>
        <li>Does not have a primary key of its own</li>
        <li>Has a <strong>partial key (discriminator)</strong> - an attribute that is unique within the context of the parent entity</li>
        <li>Participates in an <strong>identifying relationship</strong> (shown with double diamond) with a strong entity</li>
        <li>Must have mandatory participation (|‚Äî) with the parent entity</li>
        <li>Cannot exist without the parent entity</li>
    </ul>

    <div class="example">
<strong>Example 1: Building and Room</strong>

BUILDING (Strong Entity - Single Rectangle)
  <strong><u>buildingID</u></strong>
  <strong>buildingName</strong>
  address

         |‚Äî‚Äî‚Äî‚Äî‚Äîcontains (Double Diamond)‚Äî‚Äî‚Äî‚Äî‚Äî|‚â∫

ROOM (Weak Entity - Double Rectangle)
  <u>roomNumber</u>    (Partial key - dashed underline)
  capacity
  roomType

<strong>Explanation:</strong>
- ROOM is a weak entity because roomNumber alone doesn't uniquely identify a room
- Room "101" exists in multiple buildings
- The full key is {buildingID, roomNumber} combined
- A room cannot exist without a building
- roomNumber is the partial key (discriminator)
- "contains" is an identifying relationship (double diamond)

<strong>Implementation:</strong>
BUILDING(buildingID, buildingName, address)
PK: buildingID

ROOM(buildingID, roomNumber, capacity, roomType)
PK: {buildingID, roomNumber}
FK: buildingID REFERENCES BUILDING(buildingID)
    </div>

    <div class="example">
<strong>Example 2: Employee and Dependent</strong>

EMPLOYEE (Strong Entity)
  <strong><u>employeeID</u></strong>
  <strong>firstName</strong>
  <strong>lastName</strong>

         |‚Äî‚Äî‚Äî‚Äî‚Äîhas (Double Diamond)‚Äî‚Äî‚Äî‚Äî‚Äîo‚â∫

DEPENDENT (Weak Entity)
  <u>dependentName</u>    (Partial key)
  dateOfBirth
  relationship

<strong>Explanation:</strong>
- DEPENDENT is weak because dependentName alone isn't unique
- Multiple employees might have dependents with same name ("John")
- Full key is {employeeID, dependentName}
- Dependent cannot exist without the employee

<strong>Implementation:</strong>
EMPLOYEE(employeeID, firstName, lastName)
PK: employeeID

DEPENDENT(employeeID, dependentName, dateOfBirth, relationship)
PK: {employeeID, dependentName}
FK: employeeID REFERENCES EMPLOYEE(employeeID) ON DELETE CASCADE
    </div>

    <div class="insight">
        <strong>Design Decision:</strong> Use weak entities when:
        <ul>
            <li>The entity's existence depends on another entity</li>
            <li>The entity has no meaningful identifier outside its relationship</li>
            <li>Deletion of the parent should cascade to delete these entities</li>
        </ul>
    </div>
</div>

<div class="concept">
    <h3>Mandatory vs. Optional Relationships</h3>

    <div class="definition">
        <p><strong>Mandatory Relationship (Total Participation):</strong> Every instance of the entity MUST participate in the relationship. Shown with "|" (perpendicular line).</p>

        <p><strong>Optional Relationship (Partial Participation):</strong> An instance of the entity MAY OR MAY NOT participate in the relationship. Shown with "o" (circle).</p>
    </div>

    <table>
        <tr>
            <th>Notation</th>
            <th>Type</th>
            <th>Meaning</th>
            <th>Business Rule</th>
        </tr>
        <tr>
            <td><code>|‚Äî</code> or <code>|‚â∫</code></td>
            <td>Mandatory</td>
            <td>Must participate</td>
            <td>"Every order MUST have a customer"</td>
        </tr>
        <tr>
            <td><code>o‚Äî</code> or <code>o‚â∫</code></td>
            <td>Optional</td>
            <td>May participate</td>
            <td>"A customer MAY have orders (or not)"</td>
        </tr>
    </table>

    <div class="example">
<strong>Example: Analyzing Mandatory vs. Optional</strong>

EMPLOYEE ‚Äîo‚Äî‚Äî‚Äîdrives‚Äî‚Äî‚Äîo‚Äî COMPANY_CAR
          ‚Üë                ‚Üë
      Optional         Optional

<strong>Reading:</strong>
- LEFT: An employee may or may not drive a company car (optional)
- RIGHT: A company car may or may not be assigned to an employee (optional)
- Both are optional because not all employees get cars, and some cars might be unassigned

---

STUDENT ‚Äîo‚â∫‚Äî‚Äîenrolls‚Äî‚Äî|‚Äî ENROLLMENT ‚Äî|‚Äî‚Äîfor‚Äî‚Äî|‚Äî COURSE
         ‚Üë              ‚Üë               ‚Üë            ‚Üë
     Optional      Mandatory       Mandatory    Mandatory

<strong>Reading:</strong>
- STUDENT to ENROLLMENT: Optional (a student might not be enrolled in any courses yet)
- ENROLLMENT to STUDENT: Mandatory (every enrollment record MUST have a student)
- ENROLLMENT to COURSE: Mandatory (every enrollment record MUST be for a course)
- COURSE to ENROLLMENT: Optional (a new course might not have enrollments yet)

<strong>Business Rules Enforced:</strong>
1. Cannot create enrollment without both student and course (mandatory on both)
2. Students can exist without enrollments (optional participation)
3. Courses can exist without enrollments (optional participation)
    </div>

    <div class="example">
<strong>Example: Identifying Mandatory Relationships</strong>

Questions to ask when determining mandatory vs. optional:

<strong>For "ORDER belongs to CUSTOMER":</strong>
Q: Can an order exist without a customer?
A: NO ‚Üí Mandatory (|‚Äî) on customer side

<strong>For "CUSTOMER places ORDERS":</strong>
Q: Can a customer exist without orders?
A: YES (new customer hasn't ordered yet) ‚Üí Optional (o‚â∫) on order side

<strong>Result:</strong>
CUSTOMER ‚Äî|‚Äî‚Äî‚Äîplaces‚Äî‚Äî‚Äîo‚â∫‚Äî ORDER

Translation: "Each order must belong to exactly one customer, but a customer may have zero or more orders"
    </div>

    <div class="insight">
        <strong>Implementation Note:</strong> Mandatory relationships (|) typically translate to NOT NULL foreign keys in the database, while optional relationships (o) allow NULL foreign keys.
    </div>
</div>

<div class="concept">
    <h3>Crow's Feet Notation - Cardinality & Participation</h3>

    <div class="definition">
        <p><strong>Crow's Feet Notation:</strong> A widely-used method for showing cardinality (how many) and participation (optional/mandatory) in relationships. Named for the three-pronged "crow's foot" symbol.</p>
    </div>

    <p><strong>Reading Crow's Feet:</strong> The symbols appear at the ENDS of relationship lines, near each entity.</p>

    <h4>Cardinality Symbols (How Many):</h4>

    <table>
        <tr>
            <th>Symbol</th>
            <th>Meaning</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><code>‚Äî</code> (single line)</td>
            <td>One</td>
            <td>Exactly one instance</td>
        </tr>
        <tr>
            <td><code>‚â∫</code> (crow's foot)</td>
            <td>Many</td>
            <td>Zero, one, or more instances</td>
        </tr>
    </table>

    <h4>Participation Symbols (Optional/Required):</h4>

    <table>
        <tr>
            <th>Symbol</th>
            <th>Meaning</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><code>|</code> (perpendicular line)</td>
            <td>Mandatory</td>
            <td>Must participate (required)</td>
        </tr>
        <tr>
            <td><code>o</code> (circle)</td>
            <td>Optional</td>
            <td>May or may not participate</td>
        </tr>
    </table>

    <h4>Combined Notation (The Four Possibilities):</h4>

    <table>
        <tr>
            <th>Symbol</th>
            <th>Reads As</th>
            <th>Meaning</th>
            <th>Example</th>
        </tr>
        <tr>
            <td><code>|‚Äî</code></td>
            <td>Mandatory One</td>
            <td>Exactly one, required</td>
            <td>ORDER must have exactly one CUSTOMER</td>
        </tr>
        <tr>
            <td><code>o‚Äî</code></td>
            <td>Optional One</td>
            <td>Zero or one</td>
            <td>PERSON may have zero or one PASSPORT</td>
        </tr>
        <tr>
            <td><code>|‚â∫</code></td>
            <td>Mandatory Many</td>
            <td>One or more, required</td>
            <td>DEPARTMENT must have at least one EMPLOYEE</td>
        </tr>
        <tr>
            <td><code>o‚â∫</code></td>
            <td>Optional Many</td>
            <td>Zero, one, or more</td>
            <td>CUSTOMER may have zero or more ORDERS</td>
        </tr>
    </table>

    <div class="insight">
        <strong>Memory Aid:</strong> Think of "o" as "Optional" (both start with O), and "|" as a firm wall standing upright, making it "Mandatory."
    </div>
</div>

<div class="concept">
    <h3>Reading Crow's Feet Diagrams</h3>

    <p><strong>Key Rule:</strong> Notation appears on BOTH ends of the relationship line. Each end describes the cardinality and participation for that entity.</p>

    <p><strong>Reading Direction:</strong> You can read LEFT to RIGHT or RIGHT to LEFT. The symbols at each end tell you about participation from that entity's perspective.</p>

    <div class="example">
<strong>Example 1: Customer and Order</strong>

CUSTOMER ‚Äî|‚Äî‚Äî‚Äîplaces‚Äî‚Äî‚Äîo‚â∫‚Äî ORDER
          ‚Üë                 ‚Üë
    Exactly one      Zero or many

<strong>Reading LEFT to RIGHT (Customer to Order):</strong>
"One CUSTOMER places zero or more ORDERS"
- Look at ORDER end: o‚â∫ (optional many)
- Translation: A customer may place no orders, one order, or many orders

<strong>Reading RIGHT to LEFT (Order to Customer):</strong>
"One ORDER is placed by exactly one CUSTOMER"
- Look at CUSTOMER end: |‚Äî (mandatory one)
- Translation: Every order must have exactly one customer

<strong>Complete sentence:</strong>
"A customer places zero or more orders, and each order is placed by exactly one customer"
    </div>

    <div class="example">
<strong>Example 2: Department and Employee</strong>

DEPARTMENT ‚Äî|‚â∫‚Äî‚Äîemploys‚Äî‚Äî|‚Äî EMPLOYEE
            ‚Üë                ‚Üë
      One or many      Exactly one

<strong>Reading LEFT to RIGHT (Department to Employee):</strong>
"One DEPARTMENT employs one or more EMPLOYEES"
- Look at EMPLOYEE end: |‚â∫ (mandatory many)
- Translation: A department must have at least one employee

<strong>Reading RIGHT to LEFT (Employee to Department):</strong>
"One EMPLOYEE works in exactly one DEPARTMENT"
- Look at DEPARTMENT end: |‚Äî (mandatory one)
- Translation: Every employee must belong to exactly one department

<strong>Complete sentence:</strong>
"A department employs one or more employees, and each employee works in exactly one department"
    </div>

    <div class="example">
<strong>Example 3: Person and Driver's License (1:1 Optional)</strong>

PERSON ‚Äî|‚Äî‚Äî‚Äîhas‚Äî‚Äî‚Äîo‚Äî DRIVER_LICENSE
        ‚Üë              ‚Üë
   Exactly one   Zero or one

<strong>Reading LEFT to RIGHT:</strong>
"One PERSON has zero or one DRIVER_LICENSE"
- A person may or may not have a driver's license

<strong>Reading RIGHT to LEFT:</strong>
"One DRIVER_LICENSE belongs to exactly one PERSON"
- A license must belong to exactly one person

<strong>Complete sentence:</strong>
"A person may have zero or one driver's license, and each license belongs to exactly one person"
    </div>

    <div class="example">
<strong>Example 4: Student and Course (M:N - Before Bridge Table)</strong>

STUDENT ‚Äîo‚â∫‚Äî‚Äîenrolls in‚Äî‚Äîo‚â∫‚Äî COURSE
         ‚Üë                   ‚Üë
    Zero or many       Zero or many

<strong>Reading LEFT to RIGHT:</strong>
"One STUDENT enrolls in zero or more COURSES"
- A student may take multiple courses or none

<strong>Reading RIGHT to LEFT:</strong>
"One COURSE has zero or more STUDENTS enrolled"
- A course may have many students or none

<strong>Note:</strong> M:N relationships require a bridge table in implementation!
    </div>
</div>

<div class="concept">
    <h3>Minimum and Maximum Cardinality (m,n Notation)</h3>

    <div class="definition">
        <p><strong>(m,n) Cardinality Notation:</strong> An alternative or supplementary way to express cardinality using minimum and maximum values. Written as (min, max) near each entity.</p>
    </div>

    <p><strong>Format:</strong> (minimum, maximum)</p>
    <ul>
        <li><strong>minimum:</strong> Fewest instances that can participate (0 = optional, 1 = required)</li>
        <li><strong>maximum:</strong> Most instances that can participate (1 = one, * or n or m = many)</li>
    </ul>

    <table>
        <tr>
            <th>(m,n) Notation</th>
            <th>Crow's Feet Equivalent</th>
            <th>Meaning</th>
        </tr>
        <tr>
            <td>(1,1)</td>
            <td>|‚Äî</td>
            <td>Exactly one (mandatory)</td>
        </tr>
        <tr>
            <td>(0,1)</td>
            <td>o‚Äî</td>
            <td>Zero or one (optional)</td>
        </tr>
        <tr>
            <td>(1,*)</td>
            <td>|‚â∫</td>
            <td>One or more (mandatory many)</td>
        </tr>
        <tr>
            <td>(0,*)</td>
            <td>o‚â∫</td>
            <td>Zero or more (optional many)</td>
        </tr>
        <tr>
            <td>(1,n)</td>
            <td>|‚â∫</td>
            <td>Between 1 and n instances</td>
        </tr>
        <tr>
            <td>(3,5)</td>
            <td>Specific constraint</td>
            <td>Between 3 and 5 instances (requires check constraint)</td>
        </tr>
    </table>

    <div class="example">
<strong>Example with (m,n) Notation:</strong>

STUDENT ‚Äî‚Äî‚Äî‚Äî(0,*)‚Äî‚Äî‚Äî‚Äî enrolls in ‚Äî‚Äî‚Äî‚Äî(1,*)‚Äî‚Äî‚Äî‚Äî COURSE

Reading:
- STUDENT side: (0,*) = A student can enroll in zero or more courses
- COURSE side: (1,*) = A course must have at least one student enrolled

Alternative reading (relationship-centric):
- "A student (0,*) enrolls in (1,*) courses"
- Minimum 0 students per course would mean (0,*) on course side
    </div>

    <div class="insight">
        <strong>Converting between notations:</strong>
        <ul>
            <li>(0,1) ‚Üî o‚Äî (optional one)</li>
            <li>(1,1) ‚Üî |‚Äî (mandatory one)</li>
            <li>(0,*) ‚Üî o‚â∫ (optional many)</li>
            <li>(1,*) ‚Üî |‚â∫ (mandatory many)</li>
        </ul>
    </div>
</div>

<div class="concept">
    <h3>Complete ERD Example: University Database</h3>

    <div class="example">
<strong>Entities and Attributes:</strong>

STUDENT
  <strong><u>studentID</u></strong>
  <strong>firstName</strong>
  <strong>lastName</strong>
  <u>email</u>
  phoneNumber
  dateOfBirth

COURSE
  <strong><u>courseID</u></strong>
  <strong>courseName</strong>
  <strong>credits</strong>
  <u>courseCode</u>

INSTRUCTOR
  <strong><u>instructorID</u></strong>
  <strong>firstName</strong>
  <strong>lastName</strong>
  <u>email</u>
  officeNumber

DEPARTMENT
  <strong><u>deptID</u></strong>
  <strong>deptName</strong>
  <strong>building</strong>

<strong>Relationships with Crow's Feet:</strong>

STUDENT ‚Äîo‚â∫‚Äî‚Äî‚Äîenrolls in‚Äî‚Äî‚Äî|‚â∫‚Äî COURSE
        ‚Üë                     ‚Üë
   Zero or many        One or many

Reading:
- "A student enrolls in zero or more courses"
- "A course has one or more students enrolled"

---

INSTRUCTOR ‚Äîo‚â∫‚Äî‚Äî‚Äîteaches‚Äî‚Äî‚Äî|‚Äî COURSE
            ‚Üë                ‚Üë
       Zero or many     Exactly one

Reading:
- "An instructor teaches zero or more courses"
- "A course is taught by exactly one instructor"

---

DEPARTMENT ‚Äî|‚â∫‚Äî‚Äî‚Äîoffers‚Äî‚Äî‚Äî|‚Äî COURSE
            ‚Üë               ‚Üë
       One or many    Exactly one

Reading:
- "A department offers one or more courses"
- "A course is offered by exactly one department"

---

INSTRUCTOR ‚Äî|‚Äî‚Äî‚Äîworks in‚Äî‚Äî‚Äî|‚â∫‚Äî DEPARTMENT
            ‚Üë                 ‚Üë
       Exactly one       One or many

Reading:
- "An instructor works in exactly one department"
- "A department has one or more instructors"

<strong>Bridge Entity for M:N Relationship:</strong>

ENROLLMENT (bridge for STUDENT ‚Üî COURSE)
  <strong><u>studentID</u></strong> (FK to STUDENT)
  <strong><u>courseID</u></strong> (FK to COURSE)
  <strong><u>semester</u></strong>
  grade
  enrollmentDate

This creates two 1:M relationships:

STUDENT ‚Äî|‚Äî‚Äî‚Äîhas‚Äî‚Äî‚Äîo‚â∫‚Äî ENROLLMENT
        ‚Üë              ‚Üë
   Exactly one   Zero or many

"One student has zero or more enrollments"
"One enrollment belongs to exactly one student"

---

COURSE ‚Äî|‚Äî‚Äî‚Äîincludes‚Äî‚Äî‚Äîo‚â∫‚Äî ENROLLMENT
       ‚Üë                  ‚Üë
  Exactly one       Zero or many

"One course includes zero or more enrollments"
"One enrollment is for exactly one course"
    </div>
</div>

<div class="concept">
    <h3>Converting ERD to Relational Schema</h3>

    <p><strong>Conversion Rules:</strong></p>

    <p><strong>1. Entity ‚Üí Table</strong></p>
    <ul>
        <li>Each entity becomes a table</li>
        <li>Entity name becomes table name</li>
        <li>Attributes become columns</li>
    </ul>

    <p><strong>2. Attributes ‚Üí Columns</strong></p>
    <ul>
        <li>Primary key attributes ‚Üí PRIMARY KEY constraint</li>
        <li>Unique attributes ‚Üí UNIQUE constraint</li>
        <li>Required attributes ‚Üí NOT NULL constraint</li>
        <li>Multi-valued attributes ‚Üí Separate table with FK</li>
    </ul>

    <p><strong>3. Relationships ‚Üí Foreign Keys or Bridge Tables</strong></p>
    <ul>
        <li><strong>1:1 Relationship:</strong> Add FK in either table (or merge tables)</li>
        <li><strong>1:M Relationship:</strong> Add FK on the "many" side</li>
        <li><strong>M:N Relationship:</strong> Create bridge table with FKs to both entities</li>
    </ul>

    <div class="example">
<strong>From ERD to SQL Schema:</strong>

ERD:
STUDENT ‚Äî‚Äî‚Äî‚Äîo‚â∫‚Äî‚Äî‚Äî‚Äî ENROLLMENT ‚Äî‚Äî‚Äî‚Äî|‚Äî‚Äî‚Äî‚Äî‚Äî COURSE

SQL Tables:
CREATE TABLE STUDENT (
    studentID INT PRIMARY KEY,
    firstName VARCHAR(50) NOT NULL,
    lastName VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE
);

CREATE TABLE COURSE (
    courseID VARCHAR(10) PRIMARY KEY,
    courseName VARCHAR(100) NOT NULL,
    credits INT NOT NULL
);

CREATE TABLE ENROLLMENT (
    studentID INT,
    courseID VARCHAR(10),
    semester VARCHAR(20),
    grade CHAR(2),
    PRIMARY KEY (studentID, courseID, semester),
    FOREIGN KEY (studentID) REFERENCES STUDENT(studentID),
    FOREIGN KEY (courseID) REFERENCES COURSE(courseID)
);
    </div>
</div>

<hr>

<h2>Part 4: Functional Dependencies</h2>

<div class="concept">
    <h3>Understanding Functional Dependencies</h3>

    <div class="definition">
        <p><strong>Functional Dependency:</strong> A constraint between two sets of attributes. We write X ‚Üí Y (read "X determines Y") to mean that the value of X uniquely determines the value of Y.</p>

        <p>Formally: For any two tuples t1 and t2, if t1[X] = t2[X], then t1[Y] = t2[Y].</p>
    </div>

    <p><strong>Real-world interpretation:</strong> If you know the value(s) of X, you can look up exactly one value for Y.</p>

    <div class="example">
Examples of functional dependencies:

StudentID ‚Üí StudentName
(If you know StudentID, you can determine exactly one StudentName)

ISBN ‚Üí BookTitle, Author, Publisher
(If you know ISBN, you can determine the book's details)

{StudentID, CourseID} ‚Üí Grade
(If you know both StudentID and CourseID, you can determine the grade)
    </div>
</div>

<div class="concept">
    <h3>Set Theory (Module 1) = Database Theory</h3>

    <div class="insight">
        <strong>üìò Context Note:</strong> This section connects Module 1 and Module 2 concepts to show the mathematical continuity. While you won't see "Module 1 set theory questions" on the Module 2 exam, understanding that database theory uses the same mathematical framework may help clarify normalization concepts and functional dependencies. Think of this as the "why the math works" behind what you're learning.
    </div>

    <div class="insight">
        <strong>Key Insight:</strong> Database theory IS set theory. The symbols and operations you learned in Module 1 are the SAME symbols used in database design. A relational database is just applied set theory.
    </div>

    <p><strong>The Relational Model (What You're Actually Working With):</strong></p>
    <ul>
        <li>A <strong>table (relation)</strong> is a set of tuples</li>
        <li>A <strong>tuple (row)</strong> is an ordered set of values</li>
        <li>An <strong>attribute set</strong> is literally a set (e.g., {StudentID, Name, Major})</li>
        <li>A <strong>domain</strong> is a set of allowable values</li>
    </ul>

    <p><strong>Same Symbols, Direct Application:</strong></p>

    <table>
        <tr>
            <th>Symbol</th>
            <th>Module 1 Usage</th>
            <th>Module 2 Usage</th>
            <th>It's The Same Thing</th>
        </tr>
        <tr>
            <td><strong>‚àà</strong></td>
            <td>x ‚àà A<br>"x is in set A"</td>
            <td>tuple ‚àà STUDENT<br>"row is in table"</td>
            <td>Element membership - identical meaning</td>
        </tr>
        <tr>
            <td><strong>‚äÜ</strong></td>
            <td>A ‚äÜ B<br>"A is subset of B"</td>
            <td>Y ‚äÜ X then X ‚Üí Y is trivial<br>{Name} ‚äÜ {StudentID, Name}</td>
            <td>Subset relationship - identical meaning</td>
        </tr>
        <tr>
            <td><strong>‚à™</strong></td>
            <td>A ‚à™ B<br>"union of sets"</td>
            <td>X ‚à™ Y = combined attributes<br>{StudentID} ‚à™ {Name} = {StudentID, Name}</td>
            <td>Set union - identical operation</td>
        </tr>
        <tr>
            <td><strong>‚à©</strong></td>
            <td>A ‚à© B<br>"intersection of sets"</td>
            <td>Common attributes<br>{A, B} ‚à© {B, C} = {B}</td>
            <td>Set intersection - identical operation<br><em>Note: ‚à© behaves like AND (‚àß), not OR</em></td>
        </tr>
        <tr>
            <td><strong>‚àí</strong></td>
            <td>A ‚àí B<br>"set difference"</td>
            <td>Non-key attributes = R ‚àí PK<br>{A,B,C,D} ‚àí {A} = {B,C,D}</td>
            <td>Set difference - identical operation</td>
        </tr>
        <tr>
            <td><strong>√ó</strong></td>
            <td>A √ó B<br>"Cartesian product"</td>
            <td>STUDENT √ó COURSE<br>(all possible pairings)</td>
            <td>Cartesian product - identical operation</td>
        </tr>
        <tr>
            <td><strong>‚àÖ</strong></td>
            <td>Empty set</td>
            <td>X ‚à© Y = ‚àÖ<br>(disjoint attribute sets)</td>
            <td>Empty set - identical meaning</td>
        </tr>
        <tr>
            <td><strong>|A|</strong></td>
            <td>Cardinality<br>"size of set"</td>
            <td>|STUDENT| = 500 rows<br>|{A,B,C}| = 3 attributes</td>
            <td>Cardinality - identical meaning</td>
        </tr>
        <tr>
            <td><strong>‚àß</strong></td>
            <td>Logical AND</td>
            <td>Composite key: {A ‚àß B}<br>Conditions: (x > 5 ‚àß y < 10)</td>
            <td>Logical AND - identical operator</td>
        </tr>
        <tr>
            <td><strong>‚à®</strong></td>
            <td>Logical OR</td>
            <td>3NF: X is superkey ‚à® A is in candidate key</td>
            <td>Logical OR - identical operator</td>
        </tr>
        <tr>
            <td><strong>¬¨</strong></td>
            <td>Logical NOT</td>
            <td>Non-key means ¬¨(in any candidate key)</td>
            <td>Logical NOT - identical operator</td>
        </tr>
        <tr>
            <td><strong>‚àÄ</strong></td>
            <td>For all</td>
            <td>‚àÄt‚ÇÅ, t‚ÇÇ ‚àà R (in FD definition)</td>
            <td>Universal quantifier - identical</td>
        </tr>
        <tr>
            <td><strong>‚àÉ</strong></td>
            <td>There exists</td>
            <td>‚àÉ subset S ‚äÇ K (in candidate key test)</td>
            <td>Existential quantifier - identical</td>
        </tr>
    </table>

    <div class="insight">
        <strong>‚ö†Ô∏è Common Confusion: U-shaped symbols vs V-shaped symbols</strong>

        <p><strong>The shapes tell you what they do:</strong></p>

        <table style="margin: 10px 0;">
            <tr>
                <th>Symbol</th>
                <th>Shape</th>
                <th>Operation</th>
                <th>Meaning</th>
                <th>Example</th>
            </tr>
            <tr>
                <td><strong>‚à™</strong></td>
                <td>U-shaped (cup opens UP)</td>
                <td>Union (set operation)</td>
                <td>Combine - all elements from EITHER set</td>
                <td>{A,B} ‚à™ {B,C} = {A,B,C}</td>
            </tr>
            <tr>
                <td><strong>‚à©</strong></td>
                <td>U-shaped upside-down (cap)</td>
                <td>Intersection (set operation)</td>
                <td>Common - only elements in BOTH sets</td>
                <td>{A,B} ‚à© {B,C} = {B}</td>
            </tr>
            <tr>
                <td><strong>‚à®</strong></td>
                <td>V-shaped (wedge points DOWN)</td>
                <td>Logical OR</td>
                <td>At least one proposition is true</td>
                <td>P ‚à® Q = "P or Q (or both)"</td>
            </tr>
            <tr>
                <td><strong>‚àß</strong></td>
                <td>V-shaped upside-down (points UP)</td>
                <td>Logical AND</td>
                <td>Both propositions must be true</td>
                <td>P ‚àß Q = "P and Q"</td>
            </tr>
        </table>

        <p><strong>Key Pattern - The Correspondence:</strong></p>
        <ul>
            <li><strong>U-shaped ‚à™ (union)</strong> ‚Üî <strong>V-shaped ‚à® (OR)</strong> ‚Äî combine/at least one</li>
            <li><strong>‚à© (intersection)</strong> ‚Üî <strong>‚àß (AND)</strong> ‚Äî common/both required</li>
        </ul>

        <p><strong>Memory trick:</strong> Think of the shapes as pairs:</p>
        <ul>
            <li><strong>U-shapes (‚à™ and ‚à©)</strong> operate on SETS ‚Üí give you a set back</li>
            <li><strong>V-shapes (‚à® and ‚àß)</strong> operate on LOGIC ‚Üí give you true/false back</li>
        </ul>

        <p><strong>Example showing the parallel:</strong></p>
        <pre>
SET OPERATIONS (work with collections):
  {A, B} ‚à™ {B, C} = {A, B, C}   ‚Üê union: everything from either set
  {A, B} ‚à© {B, C} = {B}         ‚Üê intersection: only what's in both sets

LOGICAL OPERATIONS (work with true/false):
  True ‚à® False = True           ‚Üê OR: at least one is true
  True ‚àß False = False          ‚Üê AND: both must be true

The math is parallel:
  ‚à™ behaves like ‚à® (combine/either)
  ‚à© behaves like ‚àß (common/both)
        </pre>
    </div>

    <div class="example">
<strong>Example: Same Math, Just Applied to Attributes</strong>

Given attribute sets:
- R = {StudentID, Name, Major, GPA}  (complete set)
- PK = {StudentID}                    (primary key)
- X = {StudentID, Major}
- Y = {Name}

<strong>Apply Module 1 set operations:</strong>

1. <strong>Subset test:</strong> PK ‚äÜ R?
   Yes, because StudentID ‚àà R

2. <strong>Union:</strong> X ‚à™ Y = ?
   {StudentID, Major} ‚à™ {Name} = {StudentID, Major, Name}

3. <strong>Intersection:</strong> X ‚à© Y = ?
   {StudentID, Major} ‚à© {Name} = ‚àÖ  (disjoint sets)

4. <strong>Difference:</strong> R ‚àí PK = ?
   {StudentID, Name, Major, GPA} ‚àí {StudentID} = {Name, Major, GPA}
   ‚Ü≥ These are the "non-key attributes"

5. <strong>Trivial FD test:</strong> Is Y ‚äÜ X?
   Is {Name} ‚äÜ {StudentID, Major}?
   No, because Name ‚àâ X
   ‚Ü≥ Therefore X ‚Üí Y is <strong>non-trivial</strong> (meaningful dependency!)
    </div>

    <div class="example">
<strong>Example: Why Trivial Dependencies Don't Matter</strong>

<strong>Module 1 logic:</strong> If A ‚äÜ B, then "all elements of A are in B" is trivially true.

<strong>Module 2 application:</strong> If Y ‚äÜ X, then X ‚Üí Y is trivially true.

<strong>Why it's trivial:</strong>
{StudentID, Name} ‚Üí Name

This says "if you know StudentID and Name, you can determine Name"
Well... of course you can, you already have it! (Name ‚äÜ {StudentID, Name})

<strong>Trivial = not useful for database design</strong>
We only care about non-trivial dependencies where Y ‚äÑ X.
    </div>

    <div class="example">
<strong>Example: Formal Definitions Use Exact Module 1 Symbols</strong>

<strong>Functional Dependency (formal):</strong>
X ‚Üí Y means: ‚àÄt‚ÇÅ, t‚ÇÇ ‚àà R, (t‚ÇÅ[X] = t‚ÇÇ[X]) ‚áí (t‚ÇÅ[Y] = t‚ÇÇ[Y])

Breaking it down with Module 1 knowledge:
- <strong>‚àÄ</strong> = "for all" (universal quantifier)
- <strong>‚àà</strong> = "element of" (membership)
- <strong>‚áí</strong> = "implies" (if-then)
- <strong>R</strong> = relation (a set of tuples)

Translation: "For all tuple pairs in the relation, if they match on X, then they must match on Y"

---

<strong>Candidate Key (formal):</strong>
K is a candidate key ‚áî (K ‚Üí R) ‚àß (‚àÑS ‚äÇ K such that S ‚Üí R)

Breaking it down:
- <strong>‚áî</strong> = "if and only if" (biconditional)
- <strong>‚àß</strong> = "and" (conjunction)
- <strong>‚àÑ</strong> = "there does not exist" (negated existential)
- <strong>‚äÇ</strong> = "proper subset" (subset but not equal)

Translation: "K is a candidate key if and only if K determines all attributes AND there's no proper subset of K that also determines all attributes"

This is EXACTLY the same math as Module 1!
    </div>
</div>

<div class="concept">
    <h3>Complete Symbol Reference</h3>

    <p><strong>All symbols from Module 1 used in Module 2:</strong></p>

    <table>
        <tr>
            <th>Symbol</th>
            <th>Name</th>
            <th>Meaning</th>
            <th>Example</th>
        </tr>
        <tr>
            <td><strong>‚Üí</strong></td>
            <td>Determines / Implies</td>
            <td>Functional dependency</td>
            <td>X ‚Üí Y (X determines Y)</td>
        </tr>
        <tr>
            <td><strong>‚Üí‚Üí</strong></td>
            <td>Multi-valued dependency</td>
            <td>X determines multiple values of Y</td>
            <td>ProfID ‚Üí‚Üí PhoneNumber</td>
        </tr>
        <tr>
            <td><strong>‚àà</strong></td>
            <td>Element of / Member of</td>
            <td>Belongs to a set</td>
            <td>x ‚àà A (x is an element of set A)</td>
        </tr>
        <tr>
            <td><strong>‚àâ</strong></td>
            <td>Not element of</td>
            <td>Does not belong to a set</td>
            <td>x ‚àâ A (x is not in set A)</td>
        </tr>
        <tr>
            <td><strong>‚äÜ</strong></td>
            <td>Subset or equal to</td>
            <td>All elements of first set are in second</td>
            <td>Y ‚äÜ X (Y is subset of X)</td>
        </tr>
        <tr>
            <td><strong>‚äÇ</strong></td>
            <td>Proper subset</td>
            <td>Subset but not equal</td>
            <td>Y ‚äÇ X (Y is proper subset of X)</td>
        </tr>
        <tr>
            <td><strong>‚äÑ</strong></td>
            <td>Not a subset</td>
            <td>Not all elements are contained</td>
            <td>Y ‚äÑ X (Y is not a subset of X)</td>
        </tr>
        <tr>
            <td><strong>‚à™</strong></td>
            <td>Union</td>
            <td>Combine sets (all elements from both)</td>
            <td>A ‚à™ B = {elements in A or B or both}</td>
        </tr>
        <tr>
            <td><strong>‚à©</strong></td>
            <td>Intersection</td>
            <td>Common elements</td>
            <td>A ‚à© B = {elements in both A and B}</td>
        </tr>
        <tr>
            <td><strong>‚àí</strong> or <strong>\</strong></td>
            <td>Set difference</td>
            <td>Elements in first but not second</td>
            <td>A ‚àí B = {elements in A but not in B}</td>
        </tr>
        <tr>
            <td><strong>√ó</strong></td>
            <td>Cartesian product</td>
            <td>All possible pairs</td>
            <td>A √ó B = {(a,b) | a ‚àà A, b ‚àà B}</td>
        </tr>
        <tr>
            <td><strong>‚àÖ</strong></td>
            <td>Empty set</td>
            <td>Set with no elements</td>
            <td>A ‚à© B = ‚àÖ (disjoint sets)</td>
        </tr>
        <tr>
            <td><strong>‚àÄ</strong></td>
            <td>For all / Universal quantifier</td>
            <td>Statement is true for all values</td>
            <td>‚àÄx ‚àà A (for all x in A)</td>
        </tr>
        <tr>
            <td><strong>‚àÉ</strong></td>
            <td>There exists / Existential quantifier</td>
            <td>At least one value makes statement true</td>
            <td>‚àÉx ‚àà A (there exists an x in A)</td>
        </tr>
        <tr>
            <td><strong>‚àÑ</strong></td>
            <td>Does not exist</td>
            <td>No value makes statement true</td>
            <td>‚àÑx ‚àà A such that P(x)</td>
        </tr>
        <tr>
            <td><strong>‚àß</strong></td>
            <td>AND / Conjunction</td>
            <td>Both conditions must be true</td>
            <td>P ‚àß Q (P and Q)</td>
        </tr>
        <tr>
            <td><strong>‚à®</strong></td>
            <td>OR / Disjunction</td>
            <td>At least one condition is true</td>
            <td>P ‚à® Q (P or Q)</td>
        </tr>
        <tr>
            <td><strong>¬¨</strong></td>
            <td>NOT / Negation</td>
            <td>Logical opposite</td>
            <td>¬¨P (not P)</td>
        </tr>
        <tr>
            <td><strong>‚áí</strong></td>
            <td>Implies / If-then</td>
            <td>Logical implication</td>
            <td>P ‚áí Q (if P then Q)</td>
        </tr>
        <tr>
            <td><strong>‚áî</strong></td>
            <td>If and only if / Biconditional</td>
            <td>Both directions of implication</td>
            <td>P ‚áî Q (P if and only if Q)</td>
        </tr>
        <tr>
            <td><strong>|</strong> or <strong>:</strong></td>
            <td>Such that</td>
            <td>Condition separator in set notation</td>
            <td>{x | x > 0} = {x : x > 0}</td>
        </tr>
    </table>

    <div class="example">
<strong>Examples Using Mathematical Notation:</strong>

<strong>1. Formal definition of functional dependency:</strong>
X ‚Üí Y means: ‚àÄt‚ÇÅ, t‚ÇÇ ‚àà R, if t‚ÇÅ[X] = t‚ÇÇ[X] then t‚ÇÅ[Y] = t‚ÇÇ[Y]

Translation: "For all tuples t‚ÇÅ and t‚ÇÇ in relation R, if they have the same X values,
then they must have the same Y values"

---

<strong>2. Trivial functional dependency:</strong>
X ‚Üí Y is trivial if Y ‚äÜ X

Translation: "X determines Y is trivial if Y is a subset of or equal to X"

---

<strong>3. Superkey definition:</strong>
S is a superkey if S ‚Üí R (where R is all attributes)

Translation: "S is a superkey if S determines all attributes in the relation"

---

<strong>4. Candidate key definition:</strong>
K is a candidate key if:
  (1) K ‚Üí R (K is a superkey)
  ‚àß (2) ‚àÑ proper subset S ‚äÇ K such that S ‚Üí R

Translation: "K is a candidate key if it determines all attributes AND
no proper subset of K determines all attributes"

---

<strong>5. 3NF definition using symbols:</strong>
For every non-trivial FD X ‚Üí A:
  X is a superkey ‚à® A is part of a candidate key

Translation: "For every non-trivial functional dependency X ‚Üí A,
either X is a superkey OR A is part of a candidate key"

---

<strong>6. BCNF definition using symbols:</strong>
‚àÄ non-trivial FD X ‚Üí Y, X is a superkey

Translation: "For all non-trivial functional dependencies X ‚Üí Y,
X must be a superkey"
    </div>

    <div class="insight">
        <strong>Reading Mathematical Notation:</strong>
        <ul>
            <li>Start with quantifiers (‚àÄ, ‚àÉ) - they tell you the scope</li>
            <li>Read logical operators (‚àß, ‚à®, ¬¨) like "and", "or", "not"</li>
            <li>Set operations (‚à™, ‚à©, ‚äÜ) describe relationships between groups</li>
            <li>The vertical bar | means "such that" and introduces a condition</li>
        </ul>
    </div>
</div>

<div class="concept">
    <h3>Types of Functional Dependencies</h3>

    <p><strong>Trivial Functional Dependency:</strong> X ‚Üí Y where Y ‚äÜ X</p>
    <div class="example">
{StudentID, Name} ‚Üí StudentID  (trivial, because StudentID ‚äÜ {StudentID, Name})
{StudentID, Name} ‚Üí Name        (trivial, because Name ‚äÜ {StudentID, Name})
    </div>
    <p><em>These are always true but not useful for database design.</em></p>

    <p><strong>Non-trivial Functional Dependency:</strong> X ‚Üí Y where Y ‚äÑ X</p>
    <div class="example">
StudentID ‚Üí Name, Email  (non-trivial, because {Name, Email} ‚äÑ {StudentID})
    </div>

    <p><strong>Partial Dependency:</strong> In a table with composite primary key {A, B}, an attribute depends on only part of the key.</p>
    <div class="example">
Table: ORDER_DETAIL({OrderID, ProductID}, Quantity, ProductName, Price)
Partial dependencies:
ProductID ‚Üí ProductName  (depends on part of key)
ProductID ‚Üí Price        (depends on part of key)

Formally: ‚àÉ proper subset S ‚äÇ PK such that S ‚Üí Y
    </div>

    <p><strong>Transitive Dependency:</strong> X ‚Üí Y and Y ‚Üí Z (where Y is not a candidate key), therefore X ‚Üí Z indirectly.</p>
    <div class="example">
Table: EMPLOYEE(EmpID, Name, DeptID, DeptName)
EmpID ‚Üí DeptID        (direct)
DeptID ‚Üí DeptName     (direct)
EmpID ‚Üí DeptName      (transitive through DeptID)

Formally: X ‚Üí Y ‚àß Y ‚Üí Z ‚àß Y ‚àâ candidate keys ‚áí X ‚Üí Z (transitive)
    </div>
</div>

<div class="concept">
    <h3>Armstrong's Axioms</h3>

    <p><strong>Rules for deriving functional dependencies:</strong></p>

    <p><strong>Reflexivity:</strong> If Y ‚äÜ X, then X ‚Üí Y</p>
    <div class="example">
{StudentID, Name} ‚Üí StudentID
    </div>

    <p><strong>Augmentation:</strong> If X ‚Üí Y, then XZ ‚Üí YZ</p>
    <div class="example">
If StudentID ‚Üí Name
Then {StudentID, Major} ‚Üí {Name, Major}
    </div>

    <p><strong>Transitivity:</strong> If X ‚Üí Y and Y ‚Üí Z, then X ‚Üí Z</p>
    <div class="example">
If CourseID ‚Üí InstructorID
And InstructorID ‚Üí InstructorName
Then CourseID ‚Üí InstructorName
    </div>

    <p><strong>Additional useful rules (derived from axioms):</strong></p>

    <p><strong>Union:</strong> If X ‚Üí Y and X ‚Üí Z, then X ‚Üí YZ</p>

    <p><strong>Decomposition:</strong> If X ‚Üí YZ, then X ‚Üí Y and X ‚Üí Z</p>

    <p><strong>Pseudo-transitivity:</strong> If X ‚Üí Y and WY ‚Üí Z, then WX ‚Üí Z</p>
</div>

<hr>

<h2>Part 5: Normalization - Eliminating Redundancy</h2>

<div class="concept">
    <h3>Why Normalize?</h3>

    <p><strong>Database Anomalies:</strong> Problems caused by poor table design</p>

    <p><strong>Update Anomaly:</strong> Same information stored in multiple places requires multiple updates</p>
    <div class="example">
Bad design - if instructor changes office:
CourseID | CourseName | InstructorName | InstructorOffice
CS101    | Programming| Dr. Smith      | Room 201
CS201    | Databases  | Dr. Smith      | Room 201
Must update multiple rows!
    </div>

    <p><strong>Insertion Anomaly:</strong> Cannot add data without adding unrelated data</p>
    <div class="example">
Bad design - cannot add a new instructor without a course:
CourseID | CourseName | InstructorName | InstructorOffice
(Can't insert instructor without CourseID!)
    </div>

    <p><strong>Deletion Anomaly:</strong> Deleting one piece of information causes loss of other information</p>
    <div class="example">
Bad design - if last course is deleted:
CourseID | CourseName | InstructorName | InstructorOffice
CS101    | Programming| Dr. Smith      | Room 201
(Deleting CS101 loses all information about Dr. Smith!)
    </div>
</div>

<div class="concept">
    <h3>First Normal Form (1NF)</h3>

    <div class="definition">
        <p><strong>First Normal Form:</strong> A table is in 1NF if:</p>
        <ul>
            <li>All attributes contain only atomic (indivisible) values</li>
            <li>Each attribute contains values from a single domain</li>
            <li>Each attribute has a unique name</li>
            <li>The order of rows and columns doesn't matter</li>
        </ul>
    </div>

    <p><strong>Violation 1: Non-atomic values</strong></p>
    <div class="example">
NOT in 1NF:
STUDENT(StudentID, Name, PhoneNumbers)
101 | John Smith | "555-1234, 555-5678"

FIX - Create separate table:
STUDENT(StudentID, Name)
101 | John Smith

STUDENT_PHONE(StudentID, PhoneNumber)
101 | 555-1234
101 | 555-5678
    </div>

    <p><strong>Violation 2: Repeating groups</strong></p>
    <div class="example">
NOT in 1NF:
STUDENT(StudentID, Name, Course1, Course2, Course3)
101 | John Smith | CS101 | MATH201 | PHYS101

FIX - Create separate rows:
STUDENT(StudentID, Name)
101 | John Smith

ENROLLMENT(StudentID, CourseID)
101 | CS101
101 | MATH201
101 | PHYS101
    </div>
</div>

<div class="concept">
    <h3>Second Normal Form (2NF)</h3>

    <div class="definition">
        <p><strong>Second Normal Form:</strong> A table is in 2NF if:</p>
        <ul>
            <li>It is in 1NF, AND</li>
            <li>Every non-key attribute is fully functionally dependent on the entire primary key</li>
            <li>(No partial dependencies)</li>
        </ul>
    </div>

    <p><strong>Note:</strong> 2NF only applies to tables with composite primary keys. Tables with single-attribute primary keys are automatically in 2NF if they're in 1NF.</p>

    <div class="example">
NOT in 2NF:
ORDER_DETAIL(OrderID, ProductID, Quantity, ProductName, ProductPrice, CustomerName)
PK: {OrderID, ProductID}

Partial dependencies:
ProductID ‚Üí ProductName, ProductPrice
OrderID ‚Üí CustomerName

FIX - Decompose into three tables:
ORDER(OrderID, CustomerName)
PK: OrderID

PRODUCT(ProductID, ProductName, ProductPrice)
PK: ProductID

ORDER_DETAIL(OrderID, ProductID, Quantity)
PK: {OrderID, ProductID}
FK: OrderID REFERENCES ORDER
FK: ProductID REFERENCES PRODUCT
    </div>
</div>

<div class="concept">
    <h3>Third Normal Form (3NF)</h3>

    <div class="definition">
        <p><strong>Third Normal Form:</strong> A table is in 3NF if:</p>
        <ul>
            <li>It is in 2NF, AND</li>
            <li>No non-key attribute is transitively dependent on the primary key</li>
            <li>(No transitive dependencies)</li>
        </ul>

        <p><strong>Alternative definition:</strong> For every non-trivial functional dependency X ‚Üí A, either:</p>
        <ul>
            <li>X is a superkey, OR</li>
            <li>A is part of a candidate key</li>
        </ul>
    </div>

    <div class="example">
NOT in 3NF:
EMPLOYEE(EmpID, EmpName, DeptID, DeptName, DeptLocation)
PK: EmpID

Transitive dependencies:
EmpID ‚Üí DeptID ‚Üí DeptName
EmpID ‚Üí DeptID ‚Üí DeptLocation

FIX - Decompose:
EMPLOYEE(EmpID, EmpName, DeptID)
PK: EmpID
FK: DeptID REFERENCES DEPARTMENT

DEPARTMENT(DeptID, DeptName, DeptLocation)
PK: DeptID
    </div>

    <div class="insight">
        <strong>Industry Standard:</strong> 3NF is the target for most business databases. It provides good data integrity while maintaining reasonable query performance.
    </div>
</div>

<div class="concept">
    <h3>Boyce-Codd Normal Form (BCNF)</h3>

    <div class="definition">
        <p><strong>Boyce-Codd Normal Form:</strong> A table is in BCNF if:</p>
        <ul>
            <li>It is in 3NF, AND</li>
            <li>For every non-trivial functional dependency X ‚Üí Y, X must be a superkey</li>
        </ul>

        <p><strong>Simpler definition:</strong> Every determinant must be a candidate key.</p>
    </div>

    <p><strong>BCNF is stricter than 3NF:</strong> It doesn't allow the exception in 3NF where a non-key attribute can depend on something other than a superkey if it's part of a candidate key.</p>

    <div class="example">
NOT in BCNF (but is in 3NF):
COURSE_INSTRUCTOR(CourseID, InstructorID, InstructorSpecialty)

Constraints:
- Each course can have multiple instructors
- Each instructor teaches only one specialty
- Each {Course, Specialty} pair has exactly one instructor

Candidate keys: {CourseID, InstructorID}, {CourseID, InstructorSpecialty}

Problem: InstructorID ‚Üí InstructorSpecialty
But InstructorID is not a superkey!

FIX - Decompose:
INSTRUCTOR(InstructorID, InstructorSpecialty)
PK: InstructorID

COURSE_INSTRUCTOR(CourseID, InstructorID)
PK: {CourseID, InstructorID}
FK: InstructorID REFERENCES INSTRUCTOR
    </div>

    <div class="insight">
        <strong>When to use BCNF:</strong> When data integrity is critical and complex dependencies exist. However, BCNF decomposition can sometimes lose functional dependencies.
    </div>
</div>

<div class="concept">
    <h3>Fourth Normal Form (4NF)</h3>

    <div class="definition">
        <p><strong>Multi-valued Dependency (MVD):</strong> X ‚Üí‚Üí Y means that for each value of X, there is a set of values for Y that is independent of other attributes.</p>

        <p><strong>Fourth Normal Form:</strong> A table is in 4NF if:</p>
        <ul>
            <li>It is in BCNF, AND</li>
            <li>It has no non-trivial multi-valued dependencies</li>
        </ul>
    </div>

    <div class="example">
NOT in 4NF:
PROFESSOR(ProfID, PhoneNumber, Specialty)

A professor can have multiple phone numbers (multi-valued)
A professor can have multiple specialties (multi-valued)
These two sets are independent of each other!

ProfID | PhoneNumber | Specialty
1001   | 555-1234    | Databases
1001   | 555-1234    | AI
1001   | 555-5678    | Databases
1001   | 555-5678    | AI

Problem: Redundancy! Each combination of phone and specialty creates a row.

FIX - Decompose into two tables:
PROF_PHONE(ProfID, PhoneNumber)
1001 | 555-1234
1001 | 555-5678

PROF_SPECIALTY(ProfID, Specialty)
1001 | Databases
1001 | AI
    </div>

    <div class="insight">
        <strong>When 4NF matters:</strong> When you have independent multi-valued facts about the same entity. Violating 4NF leads to unnecessary data duplication.
    </div>
</div>

<div class="concept">
    <h3>Fifth Normal Form (5NF)</h3>

    <div class="definition">
        <p><strong>Join Dependency:</strong> A constraint where a table can be reconstructed by joining multiple projections, but not by joining fewer projections.</p>

        <p><strong>Fifth Normal Form (Project-Join Normal Form):</strong> A table is in 5NF if:</p>
        <ul>
            <li>It is in 4NF, AND</li>
            <li>It cannot be further decomposed without losing information</li>
            <li>Every join dependency is implied by candidate keys</li>
        </ul>
    </div>

    <div class="example">
NOT in 5NF:
SUPPLIER_PART_PROJECT(SupplierID, PartID, ProjectID)

Business rules:
- Supplier S supplies part P
- Project J uses part P
- Supplier S supplies to project J
ALL THREE must be true for a row to exist

Problem: Three-way relationship creates redundancy

FIX - Decompose into three binary relationships:
SUPPLIER_PART(SupplierID, PartID)
PART_PROJECT(PartID, ProjectID)
PROJECT_SUPPLIER(ProjectID, SupplierID)

The original table can be reconstructed by joining all three.
    </div>

    <div class="insight">
        <strong>Practical note:</strong> 5NF violations are rare. Most databases stop at 3NF or BCNF. Consider 5NF only for complex multi-way relationships in specialized applications.
    </div>
</div>

<hr>

<h2>Part 6: Denormalization - Strategic Redundancy</h2>

<div class="concept">
    <h3>When and Why to Denormalize</h3>

    <div class="definition">
        <p><strong>Denormalization:</strong> The intentional introduction of redundancy into a normalized database design to improve query performance.</p>
    </div>

    <p><strong>Reasons to denormalize:</strong></p>
    <ul>
        <li><strong>Performance:</strong> Reduce the number of joins required for frequent queries</li>
        <li><strong>Simplification:</strong> Make complex queries easier to write and understand</li>
        <li><strong>Read-heavy workloads:</strong> When reads vastly outnumber writes</li>
        <li><strong>Reporting:</strong> Pre-aggregate data for analytics</li>
        <li><strong>Distributed systems:</strong> Reduce cross-network joins in distributed databases</li>
    </ul>

    <div class="insight">
        <strong>Trade-off:</strong> Denormalization improves read performance at the cost of write complexity, storage space, and potential data inconsistency.
    </div>
</div>

<div class="concept">
    <h3>Denormalization Techniques</h3>

    <p><strong>1. Adding Redundant Columns</strong></p>
    <div class="example">
Normalized:
ORDER(OrderID, CustomerID, OrderDate)
ORDER_ITEM(OrderID, ProductID, Quantity, Price)

Denormalized - add OrderTotal to ORDER:
ORDER(OrderID, CustomerID, OrderDate, OrderTotal)

Benefit: Query order totals without joining to ORDER_ITEM
Cost: Must update OrderTotal whenever ORDER_ITEM changes
    </div>

    <p><strong>2. Pre-joining Tables</strong></p>
    <div class="example">
Normalized:
CUSTOMER(CustomerID, Name, City)
ORDER(OrderID, CustomerID, OrderDate)

Denormalized - include customer info in orders:
ORDER(OrderID, CustomerID, CustomerName, CustomerCity, OrderDate)

Benefit: Get order with customer info without join
Cost: Customer name/city duplicated, updates more complex
    </div>

    <p><strong>3. Repeating Groups (Reversing 1NF)</strong></p>
    <div class="example">
Normalized:
PRODUCT(ProductID, Name)
PRODUCT_IMAGE(ProductID, ImageURL, DisplayOrder)

Denormalized - for small fixed number of images:
PRODUCT(ProductID, Name, Image1URL, Image2URL, Image3URL)

Benefit: Single table access
Cost: Waste space if fewer images, inflexible if need more
    </div>

    <p><strong>4. Summary Tables / Materialized Views</strong></p>
    <div class="example">
Normalized tables:
SALES(SaleID, ProductID, Quantity, Price, SaleDate)

Denormalized summary table:
DAILY_SALES_SUMMARY(Date, ProductID, TotalQuantity, TotalRevenue)

Benefit: Fast reporting without scanning entire SALES table
Cost: Must refresh summary table periodically or after changes
    </div>
</div>

<div class="concept">
    <h3>When NOT to Denormalize</h3>

    <ul>
        <li><strong>Write-heavy applications:</strong> Maintaining redundant data is too costly</li>
        <li><strong>Frequent updates:</strong> Synchronization overhead outweighs read benefits</li>
        <li><strong>Storage constraints:</strong> Can't afford the redundancy</li>
        <li><strong>Strong consistency requirements:</strong> Risk of inconsistency is unacceptable</li>
        <li><strong>Premature optimization:</strong> Normalize first, denormalize only when performance problems are measured</li>
    </ul>

    <div class="insight">
        <strong>Best Practice:</strong> Start with a normalized design (3NF or BCNF). Denormalize only when performance testing reveals specific bottlenecks that denormalization can address.
    </div>
</div>

<div class="concept">
    <h3>Maintaining Denormalized Data</h3>

    <p><strong>Techniques to keep redundant data consistent:</strong></p>

    <p><strong>Database Triggers:</strong> Automatically update redundant data when source changes</p>
    <div class="example">
CREATE TRIGGER update_order_total
AFTER INSERT OR UPDATE OR DELETE ON ORDER_ITEM
FOR EACH ROW
BEGIN
    UPDATE ORDER
    SET OrderTotal = (SELECT SUM(Quantity * Price)
                      FROM ORDER_ITEM
                      WHERE ORDER_ITEM.OrderID = NEW.OrderID)
    WHERE OrderID = NEW.OrderID;
END;
    </div>

    <p><strong>Application Logic:</strong> Update redundant data in application code</p>
    <ul>
        <li>Pros: More flexible, can implement complex business logic</li>
        <li>Cons: Consistency depends on correct application implementation</li>
    </ul>

    <p><strong>Periodic Batch Updates:</strong> Refresh denormalized data on schedule</p>
    <ul>
        <li>Appropriate for summary tables and reports</li>
        <li>Accepts eventual consistency</li>
    </ul>

    <p><strong>Materialized Views:</strong> Database-managed pre-computed results</p>
    <ul>
        <li>Database handles refresh automatically or on-demand</li>
        <li>Transparent to queries (can query like a table)</li>
    </ul>
</div>

<hr>

<h2>Practice: Putting It All Together</h2>

<div class="practice">
    <h3>Normalization Exercise</h3>

    <p><strong>Given this unnormalized table:</strong></p>
    <pre>
LIBRARY(BookID, Title, Authors, PublisherID, PublisherName,
        PublisherAddress, CopyID, Location, BorrowerID,
        BorrowerName, BorrowerEmail, DueDate)
    </pre>

    <p><strong>Dependencies:</strong></p>
    <ul>
        <li>BookID ‚Üí Title, Authors, PublisherID</li>
        <li>PublisherID ‚Üí PublisherName, PublisherAddress</li>
        <li>CopyID ‚Üí BookID, Location</li>
        <li>BorrowerID ‚Üí BorrowerName, BorrowerEmail</li>
        <li>{CopyID, BorrowerID} ‚Üí DueDate</li>
    </ul>

    <p><strong>Identify:</strong></p>
    <ol>
        <li>What normal form is this table in?</li>
        <li>What anomalies exist?</li>
        <li>How would you normalize to 3NF?</li>
    </ol>

    <p><strong>Solution:</strong></p>

    <p><em>Current state:</em> Assuming atomic values and no repeating groups, this is in 1NF. It violates 2NF and 3NF due to partial and transitive dependencies.</p>

    <p><em>Normalized design (3NF):</em></p>
    <pre>
BOOK(BookID, Title, Authors, PublisherID)
PK: BookID
FK: PublisherID REFERENCES PUBLISHER

PUBLISHER(PublisherID, PublisherName, PublisherAddress)
PK: PublisherID

BOOK_COPY(CopyID, BookID, Location)
PK: CopyID
FK: BookID REFERENCES BOOK

BORROWER(BorrowerID, BorrowerName, BorrowerEmail)
PK: BorrowerID

LOAN(CopyID, BorrowerID, DueDate)
PK: {CopyID, BorrowerID}
FK: CopyID REFERENCES BOOK_COPY
FK: BorrowerID REFERENCES BORROWER
    </pre>
</div>

<div class="practice">
    <h3>Relationship Design Exercise</h3>

    <p><strong>Design schemas for these scenarios:</strong></p>

    <p><strong>1. University Course System</strong></p>
    <ul>
        <li>Students enroll in courses</li>
        <li>Courses have prerequisites (other courses)</li>
        <li>Instructors teach courses</li>
        <li>Each course can have multiple sections</li>
        <li>Students receive grades for completed courses</li>
    </ul>

    <p><strong>2. Healthcare Appointment System</strong></p>
    <ul>
        <li>Patients schedule appointments with doctors</li>
        <li>Doctors work in multiple departments</li>
        <li>Each appointment is at a specific location (room)</li>
        <li>Patients can have multiple diagnoses</li>
        <li>Prescriptions are written during appointments</li>
    </ul>

    <p><strong>Consider:</strong></p>
    <ul>
        <li>What are the entities?</li>
        <li>What are the relationships and their cardinalities?</li>
        <li>Where are bridge tables needed?</li>
        <li>What are appropriate primary and foreign keys?</li>
        <li>Are the resulting tables in 3NF?</li>
    </ul>
</div>

<hr>

<div style="background-color: #edf2f7; padding: 20px; margin-top: 40px; border-top: 3px solid #2c5282;">
    <h3>Study Tips</h3>
    <ul>
        <li>Work through examples by hand - draw tables, identify keys and dependencies</li>
        <li>Practice decomposing tables at each normalization stage</li>
        <li>Understand the <em>why</em> behind each normal form, not just the rules</li>
        <li>For relationships, draw ERD diagrams to visualize cardinality</li>
        <li>Remember: normalization is about organizing data to eliminate anomalies</li>
    </ul>
</div>

</body>
</html>
